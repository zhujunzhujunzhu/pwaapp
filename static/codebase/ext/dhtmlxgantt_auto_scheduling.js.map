{"version":3,"sources":["webpack://[name]/webpack/universalModuleDefinition","webpack://[name]/webpack/bootstrap","webpack://[name]/./sources/ext/auto_scheduling/task_plan.ts","webpack://[name]/./sources/core/relations/links_builder.js","webpack://[name]/./sources/utils/helpers.js","webpack://[name]/./sources/ext/auto_scheduling/constraint_types.ts","webpack://[name]/./sources/core/relations/graph_helper.js","webpack://[name]/./sources/core/relations/links_common.js","webpack://[name]/./sources/ext/auto_scheduling/ui_handlers.ts","webpack://[name]/./sources/ext/auto_scheduling/loops_finder.ts","webpack://[name]/./sources/ext/auto_scheduling/connected_groups.ts","webpack://[name]/./sources/ext/auto_scheduling/asap_strategy.ts","webpack://[name]/./sources/ext/auto_scheduling/alap_strategy.ts","webpack://[name]/./sources/ext/auto_scheduling/planner.ts","webpack://[name]/./sources/ext/auto_scheduling/constraints.ts","webpack://[name]/./sources/ext/auto_scheduling.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","TaskPlan","this","link","task","start_date","end_date","latestStart","earliestStart","earliestEnd","latestEnd","latestSchedulingStart","earliestSchedulingStart","latestSchedulingEnd","earliestSchedulingEnd","kind","conflict","Create","parent","plan","undefined","gantt","getVirtualRoot","mixin","getSubtaskDates","id","config","root_id","type","types","project","$source","$target","$virtual","getLinkedTasks","includePredecessors","startIds","clearCache","_isLinksCacheEnabled","_startLinksCache","relations","visited","result","length","_getLinkedTasks","push","_endLinksCache","_collectRelations","rootObj","isChild","visitedLinks","linkKey","successors","_getSuccessors","predecessors","_getPredecessors","hashSum","rootTask","visitedTasks","output","from","tasksStack","current","pop","isTaskExists","getTask","rel","isSameParent","sourceParent","targetParent","target","hasChild","children","getChildren","units","second","minute","hour","day","week","month","quarter","year","isDate","obj","getFullYear","getMonth","getDate","arrayFilter","arr","callback","filter","getSecondsInUnit","unit","forEach","workArray","slice","arrayMap","map","resArray","arrayFind","find","arrayDifference","item","arraySome","hashToArray","hash","sortArrayOfHash","field","desc","compare","a","b","sort","throttle","timeout","wait","apply","arguments","setTimeout","isArray","Array","isValidDate","isNaN","getTime","isStringObject","Function","toString","constructor","isNumberObject","isBooleanObject","delay","timer","$cancelTimeout","$pending","args","clearTimeout","$execute","objectKeys","keys","requestAnimationFrame","w","webkitRequestAnimationFrame","msRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","cb","isEventable","attachEvent","detachEvent","ConstraintTypes","helpers","getVertices","ids","len","source","vertices","topologicalSort","edges","$incoming","successor","S","v","L","node","groupAdjacentEdges","edge","res","tarjanStronglyConnectedComponents","verticesHash","stack","edgesFromTasks","recurse","connectedComponents","getVertex","workStack","index","lowLink","onStack","e","Math","min","com","tasks","links","findLoops","cycles","component","_get_linked_task","getTarget","taskId","_get_link_target","_get_link_source","caching","formattedLinksStash","inheritedSuccessorsStash","inheritedPredecessorsStash","getPredecessorsCache","_formatLink","isSummaryTask","isChildOf","_getImplicitLinks","respectTargetOffset","auto_scheduling_move_projects","targetDates","to","getState","drag_id","calculateDuration","fromLength","fromTask","j","toLength","toTask","lag","subtaskLink","_convertToFinishToStartLink","taskParent","_isAutoSchedulable","auto_scheduling","selectOffset","selectSourceLinks","skipChild","eachTask","linksCollection","siblingLink","getLink","siblingId","siblingTask","abs","duration","_getDirectDependencies","selectSuccessors","linksIds","concat","_getInheritedDependencies","cacheCollection","stop","inheritedRelations","eachParent","parentDependencies","_getDirectSuccessors","_getInheritedSuccessors","_getDirectPredecessors","_getInheritedPredecessors","skipInherited","String","sourceTask","targetTask","finish_to_start","preferredStart","additionalLag","start_to_start","finish_to_finish","start_to_finish","attachUIHandlers","linksBuilder","loopsFinder","connectedGroupsHelper","_attachAutoSchedulingHandlers","movedTask","_scheduleAfterBatchUpdate","_autoScheduleAfterLinkChange","_autoscheduling_in_progress","batch_update","autoSchedule","_preventCircularLink","isCircularLink","callEvent","getLoopContainingLink","_preventDescendantLink","auto_scheduling_descendant_links","_datesNotEqual","dateA","dateB","taskA","taskB","valueOf","_hasDuration","_notEqualTaskDates","task1","task2","getConstraintType","constraint_date","milestone","getRelations","auto_scheduling_compatibility","getConnectedGroupRelations","updateTaskConstraints","schedule_from_end","constraint_type","constraint_types","FNLT","Date","SNET","finalizeTaskConstraints","auto_scheduling_strict","auto_scheduling_initial","changedConstraint","_autoScheduleAfterDND","newTask","relationsArray","skipped","originalLink","splice","presentLinks","updatedLinks","resetToStartLinksLags","_autoSchedule","modifiedTaskId","ext","inlineEditors","autoscheduleColumns_1","state","columnName","editorConfig","getEditorConfig","map_to","oldTask","LoopsFinder","graphHelper","_this","_graphHelper","_linksBuilder","_gantt","allRelations","isLinkExists","findCycles","breadthFirstSearch","currentVertex","queue","groupTasks","groupLinksInternal","groupLinksPublic","shift","linksArray","linksObjects","processedLinks","ConnectedGroupsHelper","getConnectedGroup","group","groups","length_1","findGroups","task_plan_1","AsapStrategy","instance","resolveRelationDate","adjacentLinks","plansHash","minStart","linkId","defaultStart","minRelationDate","relation","constraintDate","getEarliestStartDate","isSmallerOrDefault","project_start","maxEnd","getClosestWorkTime","date","dir","calculateEndDate","masterPlan","currentPlan","isEqual","isFirstSmaller","small","big","smallDate","bigDate","getPredecessorEndDate","predecessorEnd","successorStart","AlapStrategy","maxStart","maxRelationDate","getLatestEndDate","constraintStartDate","isGreaterOrDefault","project_end","getSuccessorStartDate","predecessor","alap_strategy_1","asap_strategy_1","constraint_types_1","AutoSchedulingPlanner","constraintsHelper","_constraintsHelper","_asapStrategy","_alapStrategy","generatePlan","constraints","alapStrategy","asapStrategy","_a","buildWorkCollections","orderedIds","reversedIds","relationsMap","processConstraints","iterateTasks","isAlapTask","isAsapTask","applyProjectPlan","projectPlan","reason","updateTasks","newDate","mainSequence","secondarySequence","isMainSequence","mainSequenceStrategy","secondarySequenceStrategy","currentId","limitPlanDates","processResolvedDate","effectiveStart","reverse","unshift","constraintType","ASAP","ALAP","processConstraint","ConstraintsHelper","hasConstraint","newPlan","SNLT","FNET","MSO","MFO","getConstraints","store","planner","connectedGroups","getConstraintLimitations","updatedTasks","startTask","preferInitialTaskDates","batchUpdate","payload","updateTask","resetTime","start","end","resetProjectDates","updateParentsAndCallEvents","inclusive","auto_scheduling_compatible","parseDate"],"mappings":";;;;;;;;;;0BAAA,SAAAA,EAAAC,GACA,iBAAAC,SAAA,iBAAAC,OACAA,OAAAD,QAAAD,IACA,mBAAAG,eAAAC,IACAD,OAAA,qCAAAH,GACA,iBAAAC,QACAA,QAAA,mCAAAD,IAEAD,EAAA,mCAAAC,IARA,CASCK,OAAA,WACD,mBCTA,IAAAC,KAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAP,QAGA,IAAAC,EAAAI,EAAAE,IACAC,EAAAD,EACAE,GAAA,EACAT,YAUA,OANAU,EAAAH,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAQ,GAAA,EAGAR,EAAAD,QA0DA,OArDAM,EAAAM,EAAAF,EAGAJ,EAAAO,EAAAR,EAGAC,EAAAQ,EAAA,SAAAd,EAAAe,EAAAC,GACAV,EAAAW,EAAAjB,EAAAe,IACAG,OAAAC,eAAAnB,EAAAe,GAA0CK,YAAA,EAAAC,IAAAL,KAK1CV,EAAAgB,EAAA,SAAAtB,GACA,oBAAAuB,eAAAC,aACAN,OAAAC,eAAAnB,EAAAuB,OAAAC,aAAwDC,MAAA,WAExDP,OAAAC,eAAAnB,EAAA,cAAiDyB,OAAA,KAQjDnB,EAAAoB,EAAA,SAAAD,EAAAE,GAEA,GADA,EAAAA,IAAAF,EAAAnB,EAAAmB,IACA,EAAAE,EAAA,OAAAF,EACA,KAAAE,GAAA,iBAAAF,QAAAG,WAAA,OAAAH,EACA,IAAAI,EAAAX,OAAAY,OAAA,MAGA,GAFAxB,EAAAgB,EAAAO,GACAX,OAAAC,eAAAU,EAAA,WAAyCT,YAAA,EAAAK,UACzC,EAAAE,GAAA,iBAAAF,EAAA,QAAAM,KAAAN,EAAAnB,EAAAQ,EAAAe,EAAAE,EAAA,SAAAA,GAAgH,OAAAN,EAAAM,IAAqBC,KAAA,KAAAD,IACrI,OAAAF,GAIAvB,EAAA2B,EAAA,SAAAhC,GACA,IAAAe,EAAAf,KAAA2B,WACA,WAA2B,OAAA3B,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAK,EAAAQ,EAAAE,EAAA,IAAAA,GACAA,GAIAV,EAAAW,EAAA,SAAAiB,EAAAC,GAAsD,OAAAjB,OAAAkB,UAAAC,eAAA1B,KAAAuB,EAAAC,IAGtD7B,EAAAgC,EAAA,aAIAhC,IAAAiC,EAAA,wFClFA,IAAAC,EAAA,WAiCC,SAAAA,IACCC,KAAKC,KAAO,KACZD,KAAKE,KAAO,KACZF,KAAKG,WAAa,KAClBH,KAAKI,SAAW,KAChBJ,KAAKK,YAAc,KACnBL,KAAKM,cAAgB,KACrBN,KAAKO,YAAc,KACnBP,KAAKQ,UAAY,KACjBR,KAAKS,sBAAwB,KAC7BT,KAAKU,wBAA0B,KAC/BV,KAAKW,oBAAsB,KAC3BX,KAAKY,sBAAwB,KAC7BZ,KAAKa,KAAO,OACZb,KAAKc,UAAW,EAElB,OAhDQf,EAAAgB,OAAP,SAAcC,GACb,IAAMC,EAAO,IAAIlB,EACjB,GAAIiB,EACH,IAAK,IAAMjD,KAAKkD,OACGC,IAAdF,EAAOjD,KACVkD,EAAKlD,GAAKiD,EAAOjD,IAIpB,OAAOkD,GAuCTlB,EAjDA,GAAaxC,EAAAwC,6BCAbvC,EAAAD,QAAA,SAAA4D,GACA,OACAC,eAAA,WACA,OAAAD,EAAAE,MACAF,EAAAG,mBAEAC,GAAAJ,EAAAK,OAAAC,QACAC,KAAAP,EAAAK,OAAAG,MAAAC,QACAC,WACAC,WACAC,UAAA,KAKAC,eAAA,SAAAT,EAAAU,GACA,IAAAC,GAAAX,GAGAY,GAAA,EACAhB,EAAAiB,yBACAjB,EAAAkB,mBACAF,GAAA,GAKA,IAHA,IAAAG,KACAC,KACAC,KACAzE,EAAA,EAAiBA,EAAAmE,EAAAO,OAAqB1E,IACtCiC,KAAA0C,gBAAAR,EAAAnE,GAAAwE,EAAAN,EAAAO,GAGA,QAAAzE,KAAAyE,EACAF,EAAAK,KAAAH,EAAAzE,IAMA,OAFAoE,GACAhB,EAAAyB,iBACAN,GAGAO,kBAAA,SAAAC,EAAAC,EAAAd,EAAAe,GACA,IAOAC,EAPAC,EAAA/B,EAAAgC,eAAAL,EAAAC,GAEAK,KACAnB,IACAmB,EAAAjC,EAAAkC,iBAAAP,EAAAC,IAKA,IADA,IAAAT,KACAvE,EAAA,EAAiBA,EAAAmF,EAAAT,OAAuB1E,IAExCiF,EADAC,EAAAC,EAAAnF,GAAAuF,WAIAN,EAAAC,IAAA,EACAX,EAAAK,KAAAO,EAAAnF,KAGA,IAAAA,EAAA,EAAiBA,EAAAqF,EAAAX,OAAyB1E,IAE1CiF,EADAC,EAAAG,EAAArF,GAAAuF,WAIAN,EAAAC,IAAA,EACAX,EAAAK,KAAAS,EAAArF,KAGA,OAAAuE,GAEAI,gBAAA,SAAAa,EAAAC,EAAAvB,EAAAwB,GAQA,IAPA,IAGAX,EAHAY,OAAAxC,IAAAqC,EAAApC,EAAAK,OAAAC,QAAA8B,EAEAP,GADAQ,SAIAG,IAAsBD,OAAAzB,sBAAAc,SAAA,IAEtBY,EAAAlB,QAAA,CACA,IAAAmB,EAAAD,EAAAE,MACAd,EAAAa,EAAAb,QAGA,IAAAS,EADAE,EAAAE,EAAAF,MACA,CAIAZ,EAAA3B,EAAA2C,aAAAJ,GAAAvC,EAAA4C,QAAAL,GAAA1D,KAAAoB,iBACAoC,EAAAE,IAAA,EAIA,IAFA,IAAApB,EAAAtC,KAAA6C,kBAAAC,EAAAC,EAAAd,EAAAe,GAEAjF,EAAA,EAAgBA,EAAAuE,EAAAG,OAAsB1E,IAAA,CACtC,IAAAiG,EAAA1B,EAAAvE,GACA0F,EAAAO,EAAAV,SAAAU,EACA,IAAAC,EAAAD,EAAAE,cAAAF,EAAAG,aAEAX,EADAQ,EAAAI,SAEAT,EAAAhB,MAAuBe,KAAAM,EAAAI,OAAAnC,qBAAA,EAAAc,QAAAkB,IAGvB,GAAA9C,EAAAkD,SAAAvB,EAAAvB,IACA,KAAA+C,EAAAnD,EAAAoD,YAAAzB,EAAAvB,IACA,IAAAxD,EAAA,EAAiBA,EAAAuG,EAAA7B,OAAqB1E,IACtCyF,EAAAc,EAAAvG,KACA4F,EAAAhB,MAAwBe,KAAAY,EAAAvG,GAAAkE,qBAAA,EAAAc,SAAA,MAKxB,OAAAU,sBC/GA,IAAAe,GACAC,OAAA,EACAC,OAAA,GACAC,KAAA,KACAC,IAAA,MACAC,KAAA,OACAC,MAAA,OACAC,QAAA,OACAC,KAAA,SAwEA,SAAAC,EAAAC,GACA,SAAAA,GAAA,iBAAAA,OACAA,EAAAC,aAAAD,EAAAE,UAAAF,EAAAG,SAUA,SAAAC,EAAAC,EAAAC,GACA,IAAAhD,KAEA,GAAA+C,EAAAE,OACA,OAAAF,EAAAE,OAAAD,GAEA,QAAAzH,EAAA,EAAiBA,EAAAwH,EAAA9C,OAAgB1E,IACjCyH,EAAAD,EAAAxH,QACAyE,IAAAC,QAAA8C,EAAAxH,IAGA,OAAAyE,EAkHAhF,EAAAD,SACAmI,iBAhNA,SAAAC,GACA,OAAAnB,EAAAmB,IAAAnB,EAAAG,MAgNAiB,QA7MA,SAAAL,EAAAC,GACA,GAAAD,EAAAK,QACAL,EAAAK,QAAAJ,QAGA,IADA,IAAAK,EAAAN,EAAAO,QACA/H,EAAA,EAAiBA,EAAA8H,EAAApD,OAAsB1E,IACvCyH,EAAAK,EAAA9H,OAwMAgI,SAnMA,SAAAR,EAAAC,GACA,GAAAD,EAAAS,IACA,OAAAT,EAAAS,IAAAR,GAKA,IAHA,IAAAK,EAAAN,EAAAO,QACAG,KAEAlI,EAAA,EAAiBA,EAAA8H,EAAApD,OAAsB1E,IACvCkI,EAAAtD,KAAA6C,EAAAK,EAAA9H,OAEA,OAAAkI,GA0LAC,UArLA,SAAAX,EAAAC,GACA,GAAAD,EAAAY,KACA,OAAAZ,EAAAY,KAAAX,GAEA,QAAAzH,EAAA,EAAiBA,EAAAwH,EAAA9C,OAAgB1E,IACjC,GAAAyH,EAAAD,EAAAxH,MACA,OAAAwH,EAAAxH,IAgLAuH,cACAc,gBA7FA,SAAAb,EAAAC,GACA,OAAAF,EAAAC,EAAA,SAAAc,EAAAtI,GACA,OAAAyH,EAAAa,EAAAtI,MA4FAuI,UAzGA,SAAAf,EAAAC,GACA,OAAAD,EAAA9C,OAAA,SAEA,QAAA1E,EAAA,EAAgBA,EAAAwH,EAAA9C,OAAgB1E,IAChC,GAAAyH,EAAAD,EAAAxH,KAAAwH,GACA,SAGA,UAkGAgB,YAtHA,SAAAC,GACA,IAAAhE,KAEA,QAAAlD,KAAAkH,EACAA,EAAA5G,eAAAN,IACAkD,EAAAG,KAAA6D,EAAAlH,IAIA,OAAAkD,GA8GAiE,gBAlDA,SAAAlB,EAAAmB,EAAAC,GACA,IAAAC,EAAA,SAAAC,EAAAC,GACA,OAAAD,EAAAC,GAGAvB,EAAAwB,KAAA,SAAAF,EAAAC,GACA,OAAAD,EAAAH,KAAAI,EAAAJ,GAAA,EAEAC,EAAAC,EAAAC,EAAAH,GAAAI,EAAAJ,IAAAE,EAAAE,EAAAJ,GAAAG,EAAAH,OA2CAM,SA3FA,SAAAxB,EAAAyB,GACA,IAAAC,GAAA,EAEA,kBACAA,IACA1B,EAAA2B,MAAA,KAAAC,WACAF,GAAA,EACAG,WAAA,WACAH,GAAA,GACID,MAmFJK,QA/KA,SAAApC,GACA,OAAAqC,MAAAD,QACAC,MAAAD,QAAApC,GAGAA,QAAAhE,IAAAgE,EAAAzC,QAAAyC,EAAArB,KAAAqB,EAAAvC,MA2KAsC,SACAuC,YA9IA,SAAAtC,GACA,OAAAD,EAAAC,KAAAuC,MAAAvC,EAAAwC,YA8IAC,eAxKA,SAAAzC,GACA,OAAAA,GAAA,iBAAAA,GACA,wCAAA0C,SAAAjI,UAAAkI,SAAA3J,KAAAgH,EAAA4C,cAuKAC,eAnKA,SAAA7C,GACA,OAAAA,GAAA,iBAAAA,GACA,wCAAA0C,SAAAjI,UAAAkI,SAAA3J,KAAAgH,EAAA4C,cAkKAE,gBA9JA,SAAA9C,GACA,OAAAA,GAAA,iBAAAA,GACA,yCAAA0C,SAAAjI,UAAAkI,SAAA3J,KAAAgH,EAAA4C,cA6JAG,MApFA,SAAAzC,EAAAyB,GACA,IAAAiB,EAEA1F,EAAA,WACAA,EAAA2F,iBACA3C,EAAA4C,UAAA,EACA,IAAAC,EAAAd,MAAA5H,UAAAmG,MAAA5H,KAAAkJ,WACAc,EAAAb,WAAA,WACA7B,EAAA2B,MAAAnH,KAAAqI,GACA7F,EAAA4F,UAAA,GACGnB,IAaH,OAVAzE,EAAA4F,UAAA,EACA5F,EAAA2F,eAAA,WACAG,aAAAJ,GACA1C,EAAA4C,UAAA,GAEA5F,EAAA+F,SAAA,WACA/C,IACAA,EAAA2C,kBAGA3F,GA8DAgG,WA/CA,SAAAtD,GACA,GAAAzG,OAAAgK,KACA,OAAAhK,OAAAgK,KAAAvD,GAEA,IACA5F,EADAkD,KAEA,IAAAlD,KAAA4F,EACAzG,OAAAkB,UAAAC,eAAA1B,KAAAgH,EAAA5F,IACAkD,EAAAG,KAAArD,GAGA,OAAAkD,GAqCAkG,sBAlCA,SAAAlD,GACA,IAAAmD,EAAAhL,OAOA,OANAgL,EAAAD,uBACAC,EAAAC,6BACAD,EAAAE,yBACAF,EAAAG,0BACAH,EAAAI,wBACA,SAAAC,GAAmB3B,WAAA2B,EAAA,UACnBxD,IA2BAyD,YAxBA,SAAA/D,GACA,OAAAA,EAAAgE,aAAAhE,EAAAiE,gGCtNA,SAAYC,GAEXA,EAAA,YAEAA,EAAA,YAEAA,EAAA,YAEAA,EAAA,YAEAA,EAAA,YAEAA,EAAA,YAEAA,EAAA,UAEAA,EAAA,UAhBD,CAAY7L,EAAA6L,kBAAA7L,EAAA6L,yCCAZ,IAAAC,EAAAxL,EAAA,GAEAL,EAAAD,QAAA,WACA,OACA+L,YAAA,SAAAhH,GAGA,IAFA,IACA0B,EADAuF,KAEAxL,EAAA,EAAAyL,EAAAlH,EAAAG,OAAyC1E,EAAAyL,EAASzL,IAElDwL,GADAvF,EAAA1B,EAAAvE,IACAqG,QAAAJ,EAAAI,OACAmF,EAAAvF,EAAAyF,QAAAzF,EAAAyF,OAGA,IACAlI,EADAmI,KAEA,QAAA3L,KAAAwL,EACAhI,EAAAgI,EAAAxL,GACA2L,EAAA/G,KAAApB,GAGA,OAAAmI,GAEAC,gBAAA,SAAAC,GAIA,IAHA,IAAAF,EAAA1J,KAAAsJ,YAAAM,GACApD,KAEAzI,EAAA,EAAAyL,EAAAE,EAAAjH,OAAwC1E,EAAAyL,EAASzL,IACjDyI,EAAAkD,EAAA3L,KAAyBwD,GAAAmI,EAAA3L,GAAA8D,WAAAC,WAAA+H,UAAA,GAGzB,IAAA9L,EAAA,EAAAyL,EAAAI,EAAAnH,OAAqC1E,EAAAyL,EAASzL,IAAA,CAC9C,IAAA+L,EAAAtD,EAAAoD,EAAA7L,GAAAqG,QACA0F,EAAAhI,QAAAa,KAAA5E,GACA+L,EAAAD,UAAAC,EAAAhI,QAAAW,OACA+D,EAAAoD,EAAA7L,GAAA0L,QAAA5H,QAAAc,KAAA5E,GASA,IAJA,IAAAgM,EAAAL,EAAAjE,OAAA,SAAAuE,GAAuC,OAAAxD,EAAAwD,GAAAH,YAEvCI,KAEAF,EAAAtH,QAAA,CACA,IAAAjD,EAAAuK,EAAAlG,MAEAoG,EAAAtH,KAAAnD,GAEA,IAAA0K,EAAA1D,EAAAhH,GAEA,IAAAzB,EAAA,EAAkBA,EAAAmM,EAAArI,QAAAY,OAAyB1E,IAAA,CAC3C,IAAAI,EAAAqI,EAAAoD,EAAAM,EAAArI,QAAA9D,IAAAqG,QACAjG,EAAA0L,YACA1L,EAAA0L,WACAE,EAAApH,KAAAxE,EAAAoD,KAMA,OAAA0I,GAGAE,mBAAA,SAAAP,GAGA,IAFA,IACAQ,EADAC,KAEAtM,EAAA,EAAAyL,EAAAI,EAAAnH,OAAqC1E,EAAAyL,EAASzL,IAE9CsM,GADAD,EAAAR,EAAA7L,IACA0L,UACAY,EAAAD,EAAAX,YAEAY,EAAAD,EAAAX,QAAA9G,KAAAyH,GAEA,OAAAC,GAEAC,kCAAA,SAAAZ,EAAAE,GASA,IANA,IAAAW,KACAC,KACAC,EAAAzK,KAAAmK,mBAAAP,GACAc,GAAA,EACAC,KAEA5M,EAAA,EAAiBA,EAAA2L,EAAAjH,OAAqB1E,IAAA,CACtC,IAAAV,EAAAuN,EAAAlB,EAAA3L,IACA,IAAAV,EAAAkF,QAGA,IAFA,IAAAsI,GAAAxN,GACAyN,EAAA,EACAD,EAAApI,QAAA,CACA,IAAAuH,EAAAa,EAAAhH,MAEAmG,EAAAzH,UACAyH,EAAAc,QACAd,EAAAe,QAAAD,EACAA,IACAN,EAAA7H,KAAAqH,GACAA,EAAAgB,SAAA,EACAhB,EAAAzH,SAAA,GAEAmI,GAAA,EACAd,EAAAa,EAAAT,EAAAzI,QACA,IADA,IACA0J,EAAA,EAAmBA,EAAArB,EAAAnH,OAAkBwI,IAAA,CACrC,IAAAtC,EAAAiC,EAAAhB,EAAAqB,GAAA7G,QAEA,GADAuE,EAAAyB,KAAAR,EAAAqB,QACA/J,IAAAyH,EAAAmC,MAAA,CACAD,EAAAlI,KAAAqH,GACAa,EAAAlI,KAAAgG,GACA+B,GAAA,EACA,MACO/B,EAAAqC,UACPhB,EAAAe,QAAAG,KAAAC,IAAAnB,EAAAe,QAAApC,EAAAmC,QAGA,IAAAJ,EAAA,CAGA,GAAAV,EAAAc,OAAAd,EAAAe,QAAA,CAEA,IADA,IAAAK,GAAiBC,SAAAC,WAEjB3C,EAAA6B,EAAA3G,OACAmH,SAAA,EACAI,EAAAC,MAAA1I,KAAAgG,EAAApH,IACAoH,EAAAyB,MACAgB,EAAAE,MAAA3I,KAAAgG,EAAAyB,KAAA7I,IAEAoH,GAAAqB,IAKAW,EAAAhI,KAAAyI,GAEAP,EAAApI,SACAkG,EAAAqB,GACAA,EAAAa,IAAApI,OAAA,IACAsI,QAAAG,KAAAC,IAAAnB,EAAAe,QAAApC,EAAAoC,YAMA,OAAAJ,EAEA,SAAAC,EAAArJ,GAKA,OAJAgJ,EAAAhJ,KACAgJ,EAAAhJ,IAAyBA,KAAAyJ,SAAA,EAAAF,WAAA5J,EAAA6J,aAAA7J,EAAAkJ,UAAAlJ,IAGzBqJ,EAAAhJ,KAIAgK,UAAA,SAAAjJ,GACA,IAAAkJ,KAEAnC,EAAAzD,QAAAtD,EAAA,SAAA0B,GACAA,EAAAI,QAAAJ,EAAAyF,QACA+B,EAAA7I,MAAAqB,EAAAI,OAAAJ,EAAAyF,WAGA,IAAAC,EAAA1J,KAAAsJ,YAAAhH,GAEAqI,EAAA3K,KAAAsK,kCAAAZ,EAAApH,GAOA,OANA+G,EAAAzD,QAAA+E,EAAA,SAAAc,GACAA,EAAAJ,MAAA5I,OAAA,GACA+I,EAAA7I,KAAA8I,KAIAD,uBC1KAhO,EAAAD,QAAA,SAAA4D,GAGAA,EAAAuK,iBAAA,SAAAzL,EAAA0L,GACA,IAAAzL,EAAA,KACA0L,EAAAD,EAAA1L,EAAAmE,OAAAnE,EAAAwJ,OAMA,OAJAtI,EAAA2C,aAAA8H,KACA1L,EAAAiB,EAAA4C,QAAA6H,IAGA1L,GAEAiB,EAAA0K,iBAAA,SAAA5L,GACA,OAAAkB,EAAAuK,iBAAAzL,GAAA,IAGAkB,EAAA2K,iBAAA,SAAA7L,GACA,OAAAkB,EAAAuK,iBAAAzL,GAAA,IAGA,IAAA8L,GAAA,EACAC,KACAC,KACAC,KACAC,KAGAhL,EAAAiB,qBAAA,WACA,OAAA2J,GAEA5K,EAAAkB,iBAAA,WACA2J,KACAC,KACAC,KACAC,KACAJ,GAAA,GAEA5K,EAAAyB,eAAA,WACAoJ,KACAC,KACAC,KACAC,KACAJ,GAAA,GAGA5K,EAAAiL,YAAA,SAAAnM,GAGA,GAAA8L,GAAAC,EAAA/L,EAAAsB,IACA,OAAAyK,EAAA/L,EAAAsB,IAGA,IAAAe,KACA8B,EAAApE,KAAA6L,iBAAA5L,GACAwJ,EAAAzJ,KAAA8L,iBAAA7L,GAEA,IAAAwJ,IAAArF,EACA,OAAA9B,EAGA,GAAAnB,EAAAkL,cAAAjI,IAAAjD,EAAAmL,UAAA7C,EAAAlI,GAAA6C,EAAA7C,KAAAJ,EAAAkL,cAAA5C,IAAAtI,EAAAmL,UAAAlI,EAAA7C,GAAAkI,EAAAlI,IACA,OAAAe,EAoCA,IA1BA,IAAAoB,EAAA1D,KAAAuM,kBAAAtM,EAAAwJ,EAAA,SAAArL,GACA,WACG,GAEHoO,EAAArL,EAAAK,OAAAiL,8BACAC,EAAA1M,KAAAqM,cAAAjI,GAAApE,KAAAsB,gBAAA8C,EAAA7C,KACApB,WAAAiE,EAAAjE,WACAC,SAAAgE,EAAAhE,UAEAuM,EAAA3M,KAAAuM,kBAAAtM,EAAAmE,EAAA,SAAAhG,GACA,OAAAoO,EAIApO,EAAA0D,QAAAW,QAAAtB,EAAAyL,WAAAC,SAAAzO,EAAAmD,GAOA,EANAJ,EAAA2L,mBACA3M,WAAAuM,EAAAvM,WACAC,SAAAhC,EAAA+B,WACAD,KAAAuJ,IAPA,IAeA1L,EAAA,EAAAgP,EAAArJ,EAAAjB,OAA2C1E,EAAAgP,EAAgBhP,IAE3D,IADA,IAAAiP,EAAAtJ,EAAA3F,GACAkP,EAAA,EAAAC,EAAAP,EAAAlK,OAAwCwK,EAAAC,EAAcD,IAAA,CACtD,IAAAE,EAAAR,EAAAM,GAEAG,EAAA,EAAAJ,EAAAI,IAAA,EAAAD,EAAAC,IAEAC,GACA9L,GAAAtB,EAAAsB,GACAG,KAAAzB,EAAAyB,KACA+H,OAAAuD,EAAA9M,KACAkE,OAAA+I,EAAAjN,KACAkN,KAAA,EAAAnN,EAAAmN,KAAA,GAAAA,GAGA9K,EAAAK,KAAAxB,EAAAmM,4BAAAH,EAAAjN,KAAAmN,EAAA5D,EAAArF,EAAA4I,EAAAO,WAAAJ,EAAAI,aAOA,OAHAxB,IACAC,EAAA/L,EAAAsB,IAAAe,GAEAA,GAGAnB,EAAAqM,mBAAA,SAAAtN,GACA,WAAAA,EAAAuN,iBAGAtM,EAAAoL,kBAAA,SAAAtM,EAAAe,EAAA0M,EAAAC,GACA,IAAArL,KAEA,GAAAtC,KAAAqM,cAAArL,GAAA,CAKA,IAOA4M,EAPAtJ,KASA,QAAAlG,KARA4B,KAAA6N,SAAA,SAAAzP,GACA4B,KAAAqM,cAAAjO,KACAkG,EAAAlG,EAAAmD,IAAAnD,IAEI4C,EAAAO,IAIJ+C,EAAA,CACA,IAAApE,EAAAoE,EAAAlG,GACA0P,EAAAH,EAAAzN,EAAA2B,QAAA3B,EAAA4B,QAEA8L,GAAA,EAEA,QAAA5P,EAAA,EAAmBA,EAAA8P,EAAArL,OAA4BzE,IAAA,CAC/C,IAAA+P,EAAA5M,EAAA6M,QAAAF,EAAA9P,IACAiQ,EAAAN,EAAAI,EAAA3J,OAAA2J,EAAAtE,OACAyE,EAAA5J,EAAA2J,GACA,GAAAC,IAAA,IAAAhO,EAAAuN,kBAAA,IAAAS,EAAAT,kBACAM,EAAA3J,QAAA8J,EAAA3M,IAAA2J,KAAAiD,IAAAJ,EAAAX,MAAAc,EAAAE,UACAL,EAAA3J,QAAAlE,EAAAqB,IAAA2J,KAAAiD,IAAAJ,EAAAX,MAAAlN,EAAAkO,UAAA,CACAR,GAAA,EACA,OAIAA,GACAtL,EAAAK,MAAqBzC,OAAAqB,GAAAgM,WAAArN,EAAAc,OAAAoM,IAAAM,EAAAxN,WAKrBoC,EAAAK,MAAmBzC,KAAAc,EAAAO,GAAAgM,WAAAvM,SAAAoM,IAAA,IAGnB,OAAA9K,GAGAnB,EAAAkN,uBAAA,SAAAnO,EAAAoO,GAOA,IALA,IAAAhD,KACApI,KAEAqL,EAAAD,EAAApO,EAAA2B,QAAA3B,EAAA4B,QAEA/D,EAAA,EAAiBA,EAAAwQ,EAAA9L,OAAqB1E,IAAA,CACtC,IAAAkC,EAAAD,KAAAgO,QAAAO,EAAAxQ,IACA,GAAAiC,KAAA8D,aAAA7D,EAAAwJ,SAAAzJ,KAAA8D,aAAA7D,EAAAmE,QAAA,CACA,IAAAA,EAAApE,KAAA+D,QAAA9D,EAAAmE,QACApE,KAAAwN,mBAAApJ,IACAkH,EAAA3I,KAAA3C,KAAAgO,QAAAO,EAAAxQ,MAKA,IAAAA,EAAA,EAAiBA,EAAAuN,EAAA7I,OAAkB1E,IACnCmF,IAAAsL,OAAAxO,KAAAoM,YAAAd,EAAAvN,KAGA,OAAAmF,GAGA/B,EAAAsN,0BAAA,SAAAvO,EAAAoO,GAGA,IAEAI,EAFAC,GAAA,EACAC,KAgCA,OA9BA5O,KAAA8D,aAAA5D,EAAAqB,KACAvB,KAAA6O,WAAA,SAAA7N,GAYA,IAAA8N,EAXAH,IAGA5C,IACA2C,EAAAJ,EAAArC,EAAAC,GACAlL,EAAAO,IACAqN,IAAAJ,OAAAE,EAAA1N,EAAAO,KAMAvB,KAAAqM,cAAArL,KACAhB,KAAAwN,mBAAAxM,IAGA8N,EAAA9O,KAAAqO,uBAAArN,EAAAsN,GACAvC,IACA2C,EAAA1N,EAAAO,IAAAuN,GAGAF,IAAAJ,OAAAM,IAPAH,GAAA,KAWIzO,EAAAqB,GAAAvB,MAGJ4O,GAIAzN,EAAA4N,qBAAA,SAAA7O,GACA,OAAAF,KAAAqO,uBAAAnO,GAAA,IAGAiB,EAAA6N,wBAAA,SAAA9O,GACA,OAAAF,KAAAyO,0BAAAvO,GAAA,IAGAiB,EAAA8N,uBAAA,SAAA/O,GACA,OAAAF,KAAAqO,uBAAAnO,GAAA,IAGAiB,EAAA+N,0BAAA,SAAAhP,GACA,OAAAF,KAAAyO,0BAAAvO,GAAA,IAGAiB,EAAAgC,eAAA,SAAAjD,EAAAiP,GACA,IAAAjM,EAAAlD,KAAA+O,qBAAA7O,GACA,OAAAiP,EACAjM,EAEAA,EAAAsL,OAAAxO,KAAAgP,wBAAA9O,KAIAiB,EAAAkC,iBAAA,SAAAnD,EAAAiP,GACA,IACA3M,EADAlD,EAAA8P,OAAAlP,EAAAqB,IAAA,IAAA6N,OAAAD,GAGA,GAAApD,GAAAI,EAAA7M,GACA,OAAA6M,EAAA7M,GAGA,IAAA8D,EAAApD,KAAAiP,uBAAA/O,GASA,OAPAsC,EADA2M,EACA/L,EAEAA,EAAAoL,OAAAxO,KAAAkP,0BAAAhP,IAEA6L,IACAI,EAAA7M,GAAAkD,GAEAA,GAIArB,EAAAmM,4BAAA,SAAA/L,EAAAtB,EAAAoP,EAAAC,EAAApL,EAAAC,GAEA,IAAAkG,GACAjG,OAAA7C,EACAtB,KAAAkB,EAAAK,OAAA8J,MAAAiE,gBACAhO,GAAAtB,EAAAsB,GACA6L,IAAAnN,EAAAmN,KAAA,EACA3D,OAAAxJ,EAAAwJ,OACA+F,eAAA,KACAtL,eACAC,eACAb,QAAA,MAGAmM,EAAA,EACA,OAAAxP,EAAAyB,MACA,KAAAP,EAAAK,OAAA8J,MAAAoE,eACAD,GAAAJ,EAAAjB,SACA,MACA,KAAAjN,EAAAK,OAAA8J,MAAAqE,iBACAF,GAAAH,EAAAlB,SACA,MACA,KAAAjN,EAAAK,OAAA8J,MAAAsE,gBACAH,GAAAJ,EAAAjB,SAAAkB,EAAAlB,SACA,MACA,QACAqB,EAAA,EAKA,OAFApF,EAAA+C,KAAAqC,EACApF,EAAA/G,QAAA+G,EAAA+C,IAAA,IAAA/C,EAAApK,KAAA,IAAAoK,EAAAZ,OAAA,IAAAY,EAAAjG,OACAiG,uFCzTA9M,EAAAsS,iBAAA,SACC1O,EACA2O,EACAC,EACAC,GAEA,IAAIC,EAAgC,WACnC,IA2JI3N,EACA4N,EA5JAC,GAA4B,EAShC,SAASC,EAA6B7O,EAAYtB,GAC7CkB,EAAMK,OAAOiM,kBAAoBtM,EAAMkP,8BACvClP,EAAMyL,WAAW0D,aACnBH,GAA4B,EAE5BhP,EAAMoP,aAAatQ,EAAKwJ,SAoC3B,SAAS+G,EAAqBjP,EAAYtB,GACzC,OAAIkB,EAAMsP,eAAexQ,KACxBkB,EAAMuP,UAAU,uBACfzQ,EACA8P,EAAYY,sBAAsB1Q,MAE5B,GAMT,SAAS2Q,EAAuBrP,EAAYtB,GAC3C,IAAMwJ,EAAStI,EAAM4C,QAAQ9D,EAAKwJ,QAC5BrF,EAASjD,EAAM4C,QAAQ9D,EAAKmE,QAElC,SAAKjD,EAAMK,OAAOqP,mCAEf1P,EAAMmL,UAAU7C,EAAOlI,GAAI6C,EAAO7C,KAClCJ,EAAMkL,cAAcjI,IACpBjD,EAAMmL,UAAUlI,EAAO7C,GAAIkI,EAAOlI,KAAOJ,EAAMkL,cAAc5C,KAajE,SAASqH,EACRC,EACAC,EACAC,EACAC,GAEA,QAAMH,KAAYC,MAKbD,IAAUC,KAIXD,EAAMI,UAAYH,EAAMG,UACpBhQ,EAAMiQ,cACZjR,WAAY6Q,EACZ5Q,SAAU2Q,EACV7Q,KAAMgR,IAGA/P,EAAMiQ,cACZjR,WAAY4Q,EACZ3Q,SAAU4Q,EACV9Q,KAAM+Q,KAIT,SAASI,EAAmBC,EAAcC,GACzC,QAAIT,EAAeQ,EAAMnR,WAAYoR,EAAMpR,WAAYmR,EAAOC,IAI1DpQ,EAAMqQ,kBAAkBF,KAAWnQ,EAAMqQ,kBAAkBD,MAK9DT,EACCQ,EAAMG,gBACNF,EAAME,gBACNH,EACAC,OAODT,EAAeQ,EAAMnR,WAAYoR,EAAMpR,WAAYmR,EAAOC,MACxDT,EAAeQ,EAAMlR,SAAUmR,EAAMnR,SAAUkR,EAAOC,IACvDD,EAAMlD,WAAamD,EAAMnD,UACzBkD,EAAM5P,OAASP,EAAMK,OAAOG,MAAM+P,kBAJpC,EAUD,SAASC,EAAapQ,GAIrB,OAAIJ,EAAMK,OAAOoQ,8BAET9B,EAAa9N,eAAeT,GAAI,GAGhCyO,EAAsB6B,2BAA2BtQ,GAyD1D,SAASuQ,EAAsB5R,GAC1BiB,EAAMK,OAAOuQ,mBAChB7R,EAAK8R,gBAAkB7Q,EAAMK,OAAOyQ,iBAAiBC,KACrDhS,EAAKuR,gBAAkB,IAAIU,KAAKjS,EAAKE,YAErCF,EAAK8R,gBAAkB7Q,EAAMK,OAAOyQ,iBAAiBG,KACrDlS,EAAKuR,gBAAkB,IAAIU,KAAKjS,EAAKC,aAIvC,SAASkS,EAAwBnS,GAE5BiB,EAAMK,OAAOoQ,+BAAiCzQ,EAAMK,OAAO8Q,yBAC1DpS,EAAK8R,kBAAoB7Q,EAAMK,OAAOyQ,iBAAiBG,MAC1DlS,EAAK8R,kBAAoB7Q,EAAMK,OAAOyQ,iBAAiBC,OACtDhS,EAAK8R,gBAAkB,KACvB9R,EAAKuR,gBAAkB,OA/N3BtQ,EAAM+H,YAAY,qBAAsB,WAEpCiH,GACFhP,EAAMoP,eAEPJ,GAA4B,IAa7BhP,EAAM+H,YAAY,oBAAqBkH,GACvCjP,EAAM+H,YAAY,iBAAkBkH,GAEpCjP,EAAM+H,YAAY,oBAAqB,SAAS3H,EAAYtB,GAC3D,GACCkB,EAAMK,OAAOiM,kBACZtM,EAAMkP,6BACPlP,EAAM2C,aAAa7D,EAAKmE,QACvB,CAED,IAAMA,EAASjD,EAAM4C,QAAQ9D,EAAKmE,QAC5BhB,EAAejC,EAAMkC,iBAAiBe,GACxChB,EAAaX,SACbtB,EAAMyL,WAAW0D,aACnBH,GAA4B,EAE5BhP,EAAMoP,aAAanN,EAAa,GAAGqG,QAAQ,OAM/CtI,EAAM+H,YAAY,UAAW,WAE3B/H,EAAMK,OAAOiM,iBACbtM,EAAMK,OAAO+Q,yBAEbpR,EAAMoP,iBAgCRpP,EAAM+H,YAAY,kBAAmBsH,GACrCrP,EAAM+H,YAAY,kBAAmB0H,GACrCzP,EAAM+H,YAAY,qBAAsBsH,GACxCrP,EAAM+H,YAAY,qBAAsB0H,GA4ExCzP,EAAM+H,YAAY,mBAAoB,SACrC3H,EACArC,EACAgB,GAWA,OARCiB,EAAMK,OAAOiM,iBACbtM,EAAMK,OAAOiL,gCAGbnK,EAAYqP,EAAapQ,GAEzB2O,EAAY3O,IAEN,IA0DR,IAuDIiR,EAvDEC,EAAwB,SAAS7G,EAAQ1L,GAC9C,GAAIiB,EAAMK,OAAOiM,kBAAoBtM,EAAMkP,4BAA6B,CACvE,IAAMqC,EAAUvR,EAAM4C,QAAQ6H,GAE1ByF,EAAmBnR,EAAMwS,KAC5BZ,EAAsBY,GAGrBvR,EAAMK,OAAOiL,+BAEbyD,GAAatE,GAGZzK,EAAM2L,kBAAkB5M,KAAUiB,EAAM2L,kBAAkB4F,IApE/D,SAA+B9G,EAAQ+G,GAKtC,IADA,IAAIC,GAAU,EACL7U,EAAI,EAAGA,EAAIuE,EAAUG,OAAQ1E,IAAK,CAC1C,IAAM8U,EAAe1R,EAAM6M,QAAQ2E,EAAe5U,GAAGwD,KAEpDsR,GACCA,EAAanR,OAASP,EAAMK,OAAO8J,MAAMoE,gBACzCmD,EAAanR,OAASP,EAAMK,OAAO8J,MAAMsE,kBAE1C+C,EAAeG,OAAO/U,EAAG,GACzBA,IACA6U,GAAU,GAIZ,GAAIA,EAAS,CACZ,IAAMG,KACN,IAAShV,EAAI,EAAGA,EAAI4U,EAAelQ,OAAQ1E,IAC1CgV,EAAaJ,EAAe5U,GAAGwD,KAAM,EAGtC,IAAMyR,EAAerB,EAAa/F,GAElC,IAAS7N,EAAI,EAAGA,EAAIiV,EAAavQ,OAAQ1E,IACnCgV,EAAaC,EAAajV,GAAGwD,KACjCoR,EAAehQ,KAAKqQ,EAAajV,KA4ChCkV,CAAsBrH,EAAQtJ,GAG/BnB,EAAM+R,cAActH,EAAQtJ,IAE5BnB,EAAMoP,aAAamC,EAAQnR,IAG5B8Q,EAAwBK,IAK1B,OAFApQ,EAAY,KACZ4N,EAAY,MACL,GAMJiD,EAAiB,KACrB,GAAIhS,EAAMiS,KAAOjS,EAAMiS,IAAIC,cAAe,CACzC,IACMC,GACLnT,YAAY,EACZC,UAAU,EACVgO,UAAU,EACV4D,iBAAiB,EACjBP,iBAAiB,GANItQ,EAAMiS,IAAIC,cASlBnK,YAAY,eAAgB,SAASqK,GAIlD,OAHID,EAAoBC,EAAMC,cAC7BL,EAAiBI,EAAMhS,KAEjB,IAyCTJ,EAAM+H,YAAY,sBAAuB,SACxC3H,EACArC,EACAgB,GAEA,OAAOuS,EAAsBlR,EAAIrB,KAG/BiB,EAAMiS,IAAIC,eACZlS,EAAMiS,IAAIC,cAAcnK,YAAY,eAAgB,SAASqK,GAC5D,GAAIpS,EAAMK,OAAOiM,kBAAoBtM,EAAMkP,4BAA6B,CACvE,IACMoD,EADMtS,EAAMiS,IAAIC,cACGK,gBAAgBH,EAAMC,YACpB,eAAxBC,EAAaE,QAAmD,aAAxBF,EAAaE,QAAiD,aAAxBF,EAAaE,SAC7FR,EAAiBI,EAAMhS,IAGzB,OAAO,IAITJ,EAAM+H,YAAY,iBAzDlB,SAAqC0C,EAAgB1L,GACpD,GAAIiB,EAAMK,OAAOiM,kBAAoBtM,EAAMkP,4BAA6B,CACvEmC,GAAoB,EACpB,IAAMoB,EAAUzS,EAAM4C,QAAQ6H,GAC1ByF,EAAmBnR,EAAM0T,KAC5BT,EAAiBvH,EACdzK,EAAMqQ,kBAAkBtR,KAAUiB,EAAMqQ,kBAAkBoC,KAC3D1T,EAAKuR,kBAAqBmC,EAAQnC,kBAEnCe,GAAoB,IAIvB,OAAO,IA6CRrR,EAAM+H,YAAY,oBA3ClB,SAAkC0C,EAAgB1L,GAkBjD,OAjBIiB,EAAMK,OAAOiM,kBAAoBtM,EAAMkP,6BAEzC8C,GAEAA,GAAkBvH,IAElBuH,EAAiB,KACbX,GACHV,EAAsB5R,GAEvBiB,EAAMoP,aAAarQ,EAAKqB,IAEpBiR,GACHH,EAAwBnS,KAIpB,KA4BTiB,EAAM+H,YAAY,eAAgB,WACjC+G,IAEAA,EAAgC,mGCtWlC,IAAA4D,EAAA,WA6CA,OAzCC,SAAY1S,EAAY2S,EAAkBhE,GAA1C,IAAAiE,EAAA/T,KAKAA,KAAAyQ,eAAiB,SAACxQ,GACjB,QAAS8T,EAAKpD,sBAAsB1Q,IAGrCD,KAAA2Q,sBAAwB,SAAC1Q,GACxB,IAAM6T,EAAcC,EAAKC,aACnBlE,EAAeiE,EAAKE,cACpB9S,EAAQ4S,EAAKG,OAEfC,EAAerE,EAAa9N,iBAC3Bb,EAAMiT,aAAanU,EAAKsB,MAC5B4S,EAAeA,EAAa3F,OAAOrN,EAAMiL,YAAYnM,KAMtD,IAHA,IAAMuL,EAASsI,EAAYvI,UAAU4I,GAG5BpW,EAAI,EAAGA,EAAIyN,EAAO/I,OAAkB1E,IAE5C,IADA,IAAMuN,EAAQE,EAAOzN,GAAGuN,MACf2B,EAAI,EAAGA,EAAI3B,EAAM7I,OAAQwK,IAEjC,GAAI3B,EAAM2B,IAAMhN,EAAKsB,GACpB,OAAOiK,EAAOzN,GAIjB,OAAO,MAGRiC,KAAAqU,WAAa,WACZ,IAAMP,EAAcC,EAAKC,aAGnBG,EAFeJ,EAAKE,cAEQjS,iBAClC,OAAO8R,EAAYvI,UAAU4I,IAtC7BnU,KAAKiU,cAAgBnE,EACrB9P,KAAKgU,aAAeF,EACpB9T,KAAKkU,OAAS/S,GAPhB,GAAa5D,EAAAsW,gDCwCb,SAASS,EACRtK,EACAsB,EACA/I,GAQA,IANA,IAKIgS,EALEC,GAAmBxK,GACnByK,KACAC,KACAC,KAGCH,EAAM/R,OAAS,GAErB,IAAKF,EADLgS,EAAgBC,EAAMI,SACO,CAC5BrS,EAAQgS,IAAiB,EACzBE,EAAW9R,KAAK4R,GAIhB,IAAK,IAAIxW,EAAI,EAAGA,EAAIuN,EAAM7I,OAAQ1E,IAAK,CACtC,IAAMkC,EAAOqL,EAAMvN,GAEdkC,EAAKwJ,QAAU8K,GAAiBtU,EAAKiE,cAAgBqQ,GACpDhS,EAAQtC,EAAKmE,UACjBoQ,EAAM7R,KAAK1C,EAAKmE,QAChBuQ,EAAiB1U,EAAKsB,KAAM,EAC5B+J,EAAMwH,OAAO/U,EAAG,GAChBA,KAED2W,EAAmBzU,EAAKqD,SAAWrD,GAGxBA,EAAKmE,QAAUmQ,GAAiBtU,EAAKkE,cAAgBoQ,IAC3DhS,EAAQtC,EAAKwJ,UACjB+K,EAAM7R,KAAK1C,EAAKwJ,QAChBkL,EAAiB1U,EAAKsB,KAAM,EAC5B+J,EAAMwH,OAAO/U,EAAG,GAChBA,KAED2W,EAAmBzU,EAAKqD,SAAWrD,IAMvC,IAAM4U,KACAC,KACN,IAAK,IAAM/W,KAAK4W,EACfE,EAAWlS,KAAK5E,GAEjB,IAAK,IAAMA,KAAK2W,EACfI,EAAanS,KAAK+R,EAAmB3W,IAGtC,OAASsN,MAAOoJ,EAAYnJ,MAAOuJ,EAAYE,eAAgBD,oDAGhE,IAAAE,EAAA,WA8BA,OA3BC,SAAY7T,EAAY2O,GAAxB,IAAAiE,EAAA/T,KAKAA,KAAA6R,2BAA6B,SAACtQ,GAG7B,OADc+S,EAAmB/S,EADnBwS,EAAKE,cAAcjS,qBAEpB+S,gBAGd/U,KAAAiV,kBAAoB,SAAC1T,GACpB,IAAM+J,EAAQyI,EAAKE,cAAcjS,iBACjC,QAAWd,IAAPK,EAAkB,CACrB,GAAIwS,EAAKG,OAAOnQ,QAAQxC,GAAIG,OAASqS,EAAKG,OAAO1S,OAAOG,MAAMC,QAC7D,OAASyJ,SAAWC,UAGrB,IAAM4J,EAAQZ,EAAmB/S,EAAI+J,MACrC,OACCD,MAAO6J,EAAM7J,MACbC,MAAO4J,EAAM5J,OAGd,OAxHH,SAAoBA,GASnB,IARA,IAEI7B,EACArF,EACA/G,EAJEkF,KACA4S,KAOGpX,EAAI,EAAGA,EAAIuN,EAAM7I,OAAQ1E,IASjC,GARA0L,EAAS6B,EAAMvN,GAAG0L,OAClBrF,EAASkH,EAAMvN,GAAGqG,OAClB/G,EAAO,KACFkF,EAAQkH,GAEDlH,EAAQ6B,KACnB/G,EAAO+G,GAFP/G,EAAOoM,EAIJpM,EAAM,CAIT,IAAM+X,EAAS9J,EAAM7I,OACrB0S,EAAOxS,KAAK2R,EAAmBjX,EAAMiO,EAAO/I,IACxC6S,IAAW9J,EAAM7I,SACpB1E,GAAK,GAIR,OAAOoX,EA2FEE,CAAW/J,GAAOtF,IAAI,SAAAkP,GAAS,OAAG7J,MAAO6J,EAAM7J,MAAOC,MAAO4J,EAAM5J,UAvB3EtL,KAAKiU,cAAgBnE,EACrB9P,KAAKkU,OAAS/S,GALhB,GAAa5D,EAAAyX,2GCjGb,IAAAM,EAAAzX,EAAA,IAEA0X,EAAA,oBAAAA,KAuJA,OAtJQA,EAAAxU,OAAP,SAAcI,GACb,IAAMqU,EAAW,IAAID,EAErB,OADAC,EAAStB,OAAS/S,EACXqU,GAKRD,EAAA5V,UAAA8V,oBAAA,SACC7J,EACA8J,EACAC,GAUA,IARA,IAAIC,EAAW,KACXC,EAAS,KAETC,EAAe,KACb5V,EAAOF,KAAKkU,OAAOnQ,QAAQ6H,GAC3BtJ,EAAYoT,EAActS,aAE5B2S,EAAkB,KACbhY,EAAI,EAAGA,EAAIuE,EAAUG,OAAQ1E,IAAK,CAC1C,IAAMiY,EAAW1T,EAAUvE,GAK3B+X,EAAeE,EAASxG,eAExB,IAAMyG,EAAiBjW,KAAKkW,qBAC3BF,EACAL,EACAzV,GAGGF,KAAKmW,mBAAmBJ,EAAiBE,EAAgB/V,KAC5D6V,EAAkBE,GAGlBjW,KAAKmW,mBAAmBL,EAAcG,EAAgB/V,IACtDF,KAAKmW,mBAAmBP,EAAUK,EAAgB/V,KAElD0V,EAAWK,EACXJ,EAASG,EAASzU,KAIfe,EAAUG,QAAUzC,KAAKkU,OAAO1S,OAAO4U,eACvCpW,KAAKmW,mBAAmBjW,EAAKC,WAAYH,KAAKkU,OAAO1S,OAAO4U,cAAelW,KAC9E0V,EAAW5V,KAAKkU,OAAO1S,OAAO4U,eAIhC,IAAIC,EAAS,KACTT,IACHA,EAAW5V,KAAKkU,OAAOoC,oBACtBC,KAAMX,EACNY,IAAK,SACLtW,KAAIA,IAELmW,EAASrW,KAAKkU,OAAOuC,kBACpBtW,WAAYyV,EACZxH,SAAUlO,EAAKkO,SACflO,KAAIA,KAIN,IAAMwW,EAAaf,EAAU/J,GACvB+K,EAAcrB,EAAAvV,SAASgB,OAAO2V,GAiBpC,OAfAC,EAAY1W,KAAO4V,EACnBc,EAAYzW,KAAO0L,EACnB+K,EAAYxW,WAAayV,EACzBe,EAAYvW,SAAWiW,EACvBM,EAAY9V,KAAO,OAEfkV,IACHY,EAAYjW,wBAA0BqV,EACtCY,EAAY/V,sBAAwBZ,KAAKkU,OAAOuC,kBAC/CtW,WAAY4V,EACZ3H,SAAUlO,EAAKkO,SACflO,KAAIA,KAICyW,GAGEpB,EAAA5V,UAAAiX,QAAV,SAAkB7F,EAAaC,EAAa9Q,GAC3C,OAAQF,KAAKkU,OAAO9C,aAAaL,EAAOC,EAAO9Q,IAGtCqV,EAAA5V,UAAAkX,eAAV,SAAyBC,EAAaC,EAAW7W,GAChD,OAAI4W,EAAM3F,UAAY4F,EAAI5F,YAAcnR,KAAK4W,QAAQE,EAAOC,EAAK7W,IAMxDqV,EAAA5V,UAAAwW,mBAAV,SAA6Ba,EAAiBC,EAAe/W,GAC5D,QAAW8W,IAAahX,KAAK6W,eAAeG,EAAWC,EAAS/W,KAGvDqV,EAAA5V,UAAAuX,sBAAV,SAAgC3V,EAAYoU,GAC3C,IAAM1U,EAAO0U,EAAUpU,GACjBrB,EAAOF,KAAKkU,OAAOnQ,QAAQxC,GAejC,OAZMN,IAASA,EAAKd,YAAcc,EAAKb,UAE5Ba,EAAKb,SACTa,EAAKb,SAELJ,KAAKkU,OAAOuC,kBACjBtW,WAAYc,EAAKd,WACjBiO,SAAUlO,EAAKkO,SACflO,KAAIA,IAPCA,EAAKE,UAcHmV,EAAA5V,UAAAuW,qBAAV,SAA+BF,EAAyBL,EAAuBzV,GAC9E,IAAMiX,EAAiBnX,KAAKkX,sBAC3BlB,EAASvM,OACTkM,GAEK7L,EAAY5J,EAEdkX,EAAiBpX,KAAKkU,OAAOoC,oBAChCC,KAAMY,EACNX,IAAK,SACLtW,KAAM4J,IAeP,OAXCqN,GACAnB,EAAS5I,KACM,EAAf4I,EAAS5I,KAA2B,EAAf4I,EAAS5I,MAE9BgK,EAAiBpX,KAAKkU,OAAOuC,kBAC5BtW,WAAYgX,EACZ/I,SAAyB,EAAf4H,EAAS5I,IACnBlN,KAAM4J,KAIDsN,GAET7B,EAvJA,GAAahY,EAAAgY,kGCFb,IAAAD,EAAAzX,EAAA,IAEAwZ,EAAA,oBAAAA,KA2GA,OA1GQA,EAAAtW,OAAP,SAAcI,GACb,IAAMqU,EAAW,IAAI6B,EAErB,OADA7B,EAAStB,OAAS/S,EACXqU,GAMR6B,EAAA1X,UAAA8V,oBAAA,SAAoB7J,EAAgB8J,EAA+BC,GASlE,IARA,IAAIU,EAAS,KACTR,EAAS,KACTyB,EAAW,KACXxB,EAAe,KACb5V,EAAOF,KAAKkU,OAAOnQ,QAAQ6H,GAC3BtJ,EAAYoT,EAAcxS,WAC5BqU,EAAkB,KAChBb,EAAaf,EAAU/J,GACpB7N,EAAI,EAAGA,EAAIuE,EAAUG,OAAQ1E,IAAK,CAC1C,IAAMiY,EAAW1T,EAAUvE,GAK3B+X,EAAeE,EAASxG,eACxB,IAAMyG,EAAiBjW,KAAKwX,iBAAiBxB,EAAUL,EAAWzV,GAC5DuX,EAAsBzX,KAAKkU,OAAOuC,kBAAmBtW,WAAY8V,EAAgB7H,UAAYlO,EAAKkO,SAAUlO,KAAIA,IAElHF,KAAK0X,mBAAmBH,EAAiBtB,EAAgB/V,KAC5DqX,EAAkBtB,GAEfjW,KAAK0X,mBAAmB5B,EAAc2B,EAAqBvX,IAASF,KAAK0X,mBAAmBrB,EAAQJ,EAAgB/V,KACvHmW,EAASJ,EACTqB,EAAWG,EACX5B,EAASG,EAASzU,KAIfe,EAAUG,QAAUzC,KAAKkU,OAAO1S,OAAOmW,aACvC3X,KAAK0X,mBAAmB1X,KAAKkU,OAAO1S,OAAOmW,YAAazX,EAAKE,SAAUF,KAC1EmW,EAASrW,KAAKkU,OAAO1S,OAAOmW,aAI1BtB,IAEHA,EAASrW,KAAKkU,OAAOoC,oBAAqBC,KAAMF,EAAQG,IAAK,SAAUtW,KAAIA,IAC3EoX,EAAWtX,KAAKkU,OAAOuC,kBAAmBtW,WAAYkW,EAAQjI,UAAYlO,EAAKkO,SAAUlO,KAAIA,KAG9F,IAAMyW,EAAcrB,EAAAvV,SAASgB,OAAO2V,GAapC,OAXAC,EAAY1W,KAAO4V,EACnBc,EAAYzW,KAAO0L,EACnB+K,EAAYvW,SAAWiW,EACvBM,EAAYxW,WAAamX,EACzBX,EAAY9V,KAAO,OAEf0W,IACHZ,EAAYlW,sBAAwBT,KAAKkU,OAAOuC,kBAAmBtW,WAAYoX,EAAiBnJ,UAAYlO,EAAKkO,SAAUlO,KAAIA,IAC/HyW,EAAYhW,oBAAsB4W,GAG5BZ,GAIEU,EAAA1X,UAAAkX,eAAV,SAAyBC,EAAaC,EAAW7W,GAChD,SAAI4W,EAAM3F,UAAY4F,EAAI5F,WAAanR,KAAKkU,OAAO9C,aAAa0F,EAAOC,EAAK7W,KAMnEmX,EAAA1X,UAAA+X,mBAAV,SAA6BV,EAAiBC,EAAe/W,GAC5D,QAAW8W,IAAahX,KAAK6W,eAAeI,EAASD,EAAW9W,KAGvDmX,EAAA1X,UAAAiY,sBAAV,SAAgCrW,EAAYoU,GAC3C,IAAM1U,EAAO0U,EAAUpU,GACjBrB,EAAOF,KAAKkU,OAAOnQ,QAAQxC,GAWjC,OARMN,IAASA,EAAKd,YAAcc,EAAKb,UAE5Ba,EAAKd,WACTc,EAAKd,WAELH,KAAKkU,OAAOuC,kBAAmBtW,WAAYc,EAAKb,SAAUgO,UAAYlO,EAAKkO,SAAUlO,KAAIA,IAJzFA,EAAKC,YAUHkX,EAAA1X,UAAA6X,iBAAV,SAA2BxB,EAAyBL,EAAuBzV,GAC1E,IAAMkX,EAAiBpX,KAAK4X,sBAAsB5B,EAAS5R,OAAQuR,GAC7DkC,EAAc3X,EAEhBiX,EAAiBnX,KAAKkU,OAAOoC,oBAAqBC,KAAMa,EAAgBZ,IAAK,OAAQtW,KAAM2X,IAM/F,OAJIV,GAAkBnB,EAAS5I,KAAsB,EAAf4I,EAAS5I,KAA2B,EAAf4I,EAAS5I,MACnE+J,EAAiBnX,KAAKkU,OAAOuC,kBAAmBtW,WAAYgX,EAAgB/I,SAA0B,GAAf4H,EAAS5I,IAASlN,KAAM2X,KAGzGV,GAETE,EA3GA,GAAa9Z,EAAA8Z,kGCFb,IAAAS,EAAAja,EAAA,KACAka,EAAAla,EAAA,KACAma,EAAAna,EAAA,IAEAyX,EAAAzX,EAAA,IAEAoa,EAAA,WAOC,SAAAA,EACC9W,EACA2S,EACAoE,GAEAlY,KAAKkU,OAAS/S,EACdnB,KAAKmY,mBAAqBD,EAC1BlY,KAAKgU,aAAeF,EACpB9T,KAAKoY,cAAgBL,EAAAxC,aAAaxU,OAAOI,GACzCnB,KAAKqY,cAAgBP,EAAAT,aAAatW,OAAOI,GA+R3C,OA5RC8W,EAAAtY,UAAA2Y,aAAA,SAAahW,EAA4BiW,GACxC,IAAMzE,EAAc9T,KAAKgU,aACnB7S,EAAQnB,KAAKkU,OACbgE,EAAoBlY,KAAKmY,mBACzBK,EAAexY,KAAKqY,cACpBI,EAAezY,KAAKoY,cAEpBM,EAAA1Y,KAAA2Y,qBAAArW,EAAAiW,EAAAzE,GACL8E,EAAAF,EAAAE,WACAC,EAAAH,EAAAG,YACAC,EAAAJ,EAAAI,aACAnD,EAAA+C,EAAA/C,UAeD,OAXA3V,KAAK+Y,mBAAmBH,EAAYjD,EAAWxU,EAAO+W,GAElD/W,EAAMK,OAAOuQ,kBAGP/R,KAAKgZ,aAAaH,EAAaD,EAAYV,EAAkBe,WAAYT,EAAcC,EAAcK,EAAcnD,GAInH3V,KAAKgZ,aAAaJ,EAAYC,EAAaX,EAAkBgB,WAAYT,EAAcD,EAAcM,EAAcnD,IAK9HsC,EAAAtY,UAAAwZ,iBAAA,SAAiBC,GAShB,IARA,IAEInY,EACAf,EACAD,EACAoZ,EALElY,EAAQnB,KAAKkU,OAOboF,KACGvb,EAAI,EAAGA,EAAIqb,EAAY3W,OAAQ1E,IAKvC,GAJAkC,EAAO,KACPoZ,EAAS,MACTpY,EAAOmY,EAAYrb,IAETmC,KAAV,CAIAA,EAAOiB,EAAM4C,QAAQ9C,EAAKf,MACtBe,EAAKhB,OACRA,EAAOkB,EAAM6M,QAAQ/M,EAAKhB,MAEzBoZ,EADiB,SAAdpY,EAAKJ,KACCb,KAAKkU,OAAOnQ,QAAQ9D,EAAKwJ,QAGzBzJ,KAAKkU,OAAOnQ,QAAQ9D,EAAKmE,SAIpC,IAAImV,EAAU,KAEbtY,EAAKd,YACLD,EAAKC,WAAWgR,YAAclQ,EAAKd,WAAWgR,YAE9CoI,EAAUtY,EAAKd,YAGXoZ,IAILrZ,EAAKC,WAAaoZ,EAClBrZ,EAAKE,SAAWe,EAAMsV,iBAAiBvW,GAEvCoZ,EAAY3W,KAAKzC,EAAKqB,IACtBJ,EAAMuP,UAAU,2BACfxQ,EACAqZ,EACAtZ,EACAoZ,KAGF,OAAOC,GAGErB,EAAAtY,UAAAqZ,aAAV,SACCQ,EACAC,EACAC,EACAC,EACAC,EACAd,EACAnD,GAMA,IAHA,IAAMxU,EAAQnB,KAAKkU,OACb1R,KAEGzE,EAAI,EAAGA,EAAIyb,EAAa/W,OAAQ1E,IAAK,CAC7C,IAAM8b,EAAYL,EAAazb,GACzBmC,EAAOiB,EAAM4C,QAAQ8V,GACrB5Y,EAAO0Y,EAAqBlE,oBACjCoE,EACAf,EAAae,GACblE,GAED3V,KAAK8Z,eAAe5Z,EAAMe,GACtByY,EAAexZ,GAClBF,KAAK+Z,oBAAoB7Z,EAAMe,EAAMuB,EAAQmT,GAE7CA,EAAUzV,EAAKqB,IAAMN,EAIvB,IAASlD,EAAI,EAAGA,EAAI0b,EAAkBhX,OAAQ1E,IAAK,CAC5C8b,EAAYJ,EAAkB1b,GAGpC,IAAK2b,EAFCxZ,EAAOiB,EAAM4C,QAAQ8V,IAEA,CACpB5Y,EAAO2Y,EAA0BnE,oBACtCoE,EACAf,EAAae,GACblE,GAED3V,KAAK8Z,eAAe5Z,EAAMe,GAC1BjB,KAAK+Z,oBAAoB7Z,EAAMe,EAAMuB,EAAQmT,IAG/C,OAAOnT,GAGEyV,EAAAtY,UAAAoa,oBAAV,SACC7Z,EACAe,EACAuB,EACAmT,GAEA,GAAI1U,EAAKd,YAAcH,KAAKkU,OAAOE,aAAanT,EAAKhB,MAAO,CAC3D,IAAIA,EAAO,KACPoZ,EAAS,KAWb,GAVIpY,EAAKhB,OACRA,EAAOD,KAAKkU,OAAOlG,QAAQ/M,EAAKhB,MAE/BoZ,EADiB,SAAdpY,EAAKJ,KACCb,KAAKkU,OAAOnQ,QAAQ9D,EAAKwJ,QAGzBzJ,KAAKkU,OAAOnQ,QAAQ9D,EAAKmE,SAKnClE,EAAKC,WAAWgR,YAAclQ,EAAKd,WAAWgR,YAMvC,IALPnR,KAAKkU,OAAOxD,UAAU,4BACrBxQ,EACAe,EAAKd,WACLF,EACAoZ,IAGD,OAIF1D,EAAUzV,EAAKqB,IAAMN,EACjBA,EAAKd,YACRqC,EAAOG,KAAK1B,IAIJgX,EAAAtY,UAAAma,eAAV,SAAyB5Z,EAAae,GACrC,IAAM+Y,EAAiB/Y,EAAKd,YAAcD,EAAKC,WAuC/C,OArCIc,EAAKX,eACJ0Z,EAAiB/Y,EAAKX,gBACzBW,EAAKd,WAAac,EAAKX,cACvBW,EAAKb,SAAWa,EAAKV,aAInBU,EAAKZ,aACJ2Z,EAAiB/Y,EAAKZ,cACzBY,EAAKd,WAAac,EAAKZ,YACvBY,EAAKb,SAAWa,EAAKT,WAInBS,EAAKR,uBAAyBuZ,EAAiB/Y,EAAKR,wBACvDQ,EAAKd,WAAac,EAAKR,sBACvBQ,EAAKb,SAAWa,EAAKN,qBAGlBM,EAAKP,yBAA2BsZ,EAAiB/Y,EAAKP,0BACzDO,EAAKd,WAAac,EAAKP,wBACvBO,EAAKb,SAAWa,EAAKL,uBAGlBK,EAAKd,aACJc,EAAKd,WAAac,EAAKR,uBAC1BQ,EAAKd,WAAac,EAAKP,yBACvBO,EAAKd,WAAac,EAAKZ,aACvBY,EAAKd,WAAac,EAAKX,eACvBW,EAAKb,SAAWa,EAAKN,qBACrBM,EAAKb,SAAWa,EAAKL,uBACrBK,EAAKb,SAAWa,EAAKT,WACrBS,EAAKb,SAAWa,EAAKV,eAErBU,EAAKH,UAAW,GAGXG,GAGEgX,EAAAtY,UAAAgZ,qBAAV,SAA+BrW,EAA4BiW,EAAsBzE,GAOhF,IANA,IAAM3S,EAAQnB,KAAKkU,OACb0E,EAAuB9E,EAAYnK,gBAAgBrH,GACnDuW,EAAwBD,EAAW9S,QAAQmU,UAC3CtE,KAEAmD,KACG/a,EAAI,EAAGyL,EAAMoP,EAAWnW,OAAQ1E,EAAIyL,EAAKzL,IAAK,CACtD,IAAMwD,EAAKqX,EAAW7a,IAEO,KADvBmC,EAAOiB,EAAM4C,QAAQxC,IAClBkM,kBAGTqL,EAAavX,IACZ2B,cACAE,iBAGDuS,EAAUpU,GAAM,MAGjB,IAASxD,EAAI,EAAGyL,EAAM+O,EAAY9V,OAAQ1E,EAAIyL,EAAKzL,IAAK,CACvD,IAAMmC,OAEqBgB,IAAvByU,GAFEzV,EAAOqY,EAAYxa,IAENwD,MAClBsX,EAAYqB,QAAQha,EAAKqB,IACzBqX,EAAWsB,QAAQha,EAAKqB,IACxBoU,EAAUzV,EAAKqB,IAAM,KACrBuX,EAAa5Y,EAAKqB,KACjB2B,cACAE,kBAKH,IAASrF,EAAI,EAAGyL,EAAMlH,EAAUG,OAAQ1E,EAAIyL,EAAKzL,IAAK,CACrD,IAAMiG,EAAM1B,EAAUvE,GAClB+a,EAAa9U,EAAIyF,SACpBqP,EAAa9U,EAAIyF,QAAQvG,WAAWP,KAAKqB,GAGtC8U,EAAa9U,EAAII,SACpB0U,EAAa9U,EAAII,QAAQhB,aAAaT,KAAKqB,GAI7C,OACC4U,WAAUA,EACVC,YAAWA,EACXC,aAAYA,EACZnD,UAASA,IAIDsC,EAAAtY,UAAAoZ,mBAAV,SAA6BH,EAAsBjD,EAAuBxU,EAAY+W,GACrF,IAAK,IAAIna,EAAI,EAAGA,EAAI6a,EAAWnW,OAAQ1E,IAAK,CAC3C,IAAM8b,EAAYjB,EAAW7a,GACvBmC,EAAOiB,EAAM4C,QAAQ8V,GAErBM,EAAiBjC,EAAkB1G,kBAAkBtR,GAC3D,GACCia,GACAA,IAAmBnC,EAAA5O,gBAAgBgR,MACnCD,IAAmBnC,EAAA5O,gBAAgBiR,KAClC,CACD,IAAMpZ,EAAOiX,EAAkBoC,kBAC9Bpa,EACAoV,EAAAvV,SAASgB,UAEV4U,EAAUzV,EAAKqB,IAAMN,KAIzBgX,EA/SA,GAAa1a,EAAA0a,2GCNb,IAAA5O,EAAAxL,EAAA,GACAma,EAAAna,EAAA,IACAyX,EAAAzX,EAAA,IAEA0c,EAAA,WAMC,SAAAA,EAAoBpZ,GAApB,IAAA4S,EAAA/T,KAIAA,KAAAkZ,WAAa,SAAChZ,GACb,IAAMia,EAAiBpG,EAAKvC,kBAAkBtR,GAC9C,OAAI6T,EAAKG,OAAO1S,OAAOuQ,kBAClBoI,IAAmBnC,EAAA5O,gBAAgBgR,KAMnCD,IAAmBnC,EAAA5O,gBAAgBiR,MAQzCra,KAAAiZ,WAAa,SAAC/Y,GACb,OAAQ6T,EAAKmF,WAAWhZ,IAGzBF,KAAAwR,kBAAoB,SAACtR,GAEpB,OAAIA,EAAK8R,gBACD9R,EAAK8R,gBACF+B,EAAKG,OAAO1S,OAAOuQ,kBACtBiG,EAAA5O,gBAAgBiR,KAEhBrC,EAAA5O,gBAAgBgR,MAIzBpa,KAAAwa,cAAgB,SAACta,GAChB,QAAS6T,EAAKvC,kBAAkBtR,IAGjCF,KAAAsa,kBAAoB,SAACpa,EAAae,GACjC,GAAI8S,EAAKyG,cAActa,GACtB,GACCA,EAAK8R,kBAAoBgG,EAAA5O,gBAAgBiR,MACzCna,EAAK8R,kBAAoBgG,EAAA5O,gBAAgBgR,WAGnC,GAAG/Q,EAAQ7B,YAAYtH,EAAKuR,iBAAkB,CACpD,IAAMwE,EAAiB/V,EAAKuR,gBAEtBgJ,EAAUnF,EAAAvV,SAASgB,OAAOE,GAGhC,OAFAwZ,EAAQva,KAAOA,EAAKqB,GAEZrB,EAAK8R,iBACZ,KAAKgG,EAAA5O,gBAAgBgJ,KACpBqI,EAAQna,cAAgB,IAAI6R,KAAK8D,GACjCwE,EAAQla,YAAcwT,EAAKG,OAAOuC,kBACjCtW,WAAYsa,EAAQna,cACpB8N,SAAUlO,EAAKkO,SACflO,KAAIA,IAELua,EAAQxa,KAAO,KACf,MACD,KAAK+X,EAAA5O,gBAAgBsR,KACpBD,EAAQpa,YAAc,IAAI8R,KAAK8D,GAC/BwE,EAAQja,UAAYuT,EAAKG,OAAOuC,kBAC/BtW,WAAYsa,EAAQpa,YACpB+N,SAAUlO,EAAKkO,SACflO,KAAIA,IAELua,EAAQxa,KAAO,KACf,MACD,KAAK+X,EAAA5O,gBAAgBuR,KACpBF,EAAQna,cAAgByT,EAAKG,OAAOuC,kBACnCtW,WAAY8V,EACZ7H,UAAWlO,EAAKkO,SAChBlO,KAAIA,IAELua,EAAQla,YAAc,IAAI4R,KAAK8D,GAC/BwE,EAAQxa,KAAO,KACf,MACD,KAAK+X,EAAA5O,gBAAgB8I,KACpBuI,EAAQpa,YAAc0T,EAAKG,OAAOuC,kBACjCtW,WAAY8V,EACZ7H,UAAWlO,EAAKkO,SAChBlO,KAAIA,IAELua,EAAQja,UAAY,IAAI2R,KAAK8D,GAC7BwE,EAAQxa,KAAO,KACf,MACD,KAAK+X,EAAA5O,gBAAgBwR,IACpBH,EAAQna,cAAgB,IAAI6R,KAAK8D,GACjCwE,EAAQla,YAAcwT,EAAKG,OAAOuC,kBACjCtW,WAAYsa,EAAQna,cACpB8N,SAAUlO,EAAKkO,SACflO,KAAIA,IAELua,EAAQpa,YAAcoa,EAAQna,cAC9Bma,EAAQja,UAAYia,EAAQla,YAC5Bka,EAAQxa,KAAO,KACf,MACD,KAAK+X,EAAA5O,gBAAgByR,IACpBJ,EAAQna,cAAgByT,EAAKG,OAAOuC,kBACnCtW,WAAY8V,EACZ7H,UAAWlO,EAAKkO,SAChBlO,KAAIA,IAELua,EAAQla,YAAcwT,EAAKG,OAAOuC,kBACjCtW,WAAYsa,EAAQna,cACpB8N,SAAUlO,EAAKkO,SACflO,KAAIA,IAELua,EAAQpa,YAAcoa,EAAQna,cAC9Bma,EAAQja,UAAYia,EAAQla,YAC5Bka,EAAQxa,KAAO,KAIjB,OAAOwa,EAIT,OAAOxZ,GAGRjB,KAAA8a,eAAiB,SAACvZ,EAAYe,GAC7B,IAoBIsB,EApBEpB,KACA6I,KAEA0P,EAAQ,SAAC7a,GACVmL,EAAMnL,EAAKqB,KAIXwS,EAAKyG,cAActa,KAAU6T,EAAKG,OAAO7H,cAAcnM,KAC1DmL,EAAMnL,EAAKqB,IAAMrB,IAInB,GAAI6T,EAAKG,OAAOpQ,aAAavC,GAAK,CACjC,IAAMrB,EAAO6T,EAAKG,OAAOnQ,QAAQxC,GACjCwZ,EAAM7a,GAMP,GAHA6T,EAAKG,OAAOrG,SAAS,SAAA3N,GAAQ,OAAA6a,EAAM7a,IAAOqB,GAGtCe,EACH,IAAK,IAAIvE,EAAI,EAAGA,EAAIuE,EAAUG,OAAQ1E,IAAK,CAC1C,IAAMiG,EAAM1B,EAAUvE,GACjBsN,EAAMrH,EAAII,UACdR,EAAUmQ,EAAKG,OAAOnQ,QAAQC,EAAII,QAClC2W,EAAMnX,IAEFyH,EAAMrH,EAAIyF,UACd7F,EAAUmQ,EAAKG,OAAOnQ,QAAQC,EAAIyF,QAClCsR,EAAMnX,IAKT,IAAK,IAAMgI,KAAUP,EACpB7I,EAAOG,KAAK0I,EAAMO,IAGnB,OAAOpJ,GApKPxC,KAAKkU,OAAS/S,EAsKhB,OA5KQoZ,EAAAxZ,OAAP,SAAcI,GACb,OAAO,IAAIoZ,EAAkBpZ,IA2K/BoZ,EA7KA,GAAahd,EAAAgd,yCCJb1c,EAAA,GAAAA,CAAAsD,GAEA,IAAA2O,EAAAjS,EAAA,GAAAA,CAAAsD,GACA2S,EAAAjW,EAAA,GAAAA,CAAAsD,GACAiI,EAAAvL,EAAA,IAAAuL,gBAEA8O,EAAAra,EAAA,KAAA0c,kBAAAxZ,OACAI,GAKA6Z,EAAA,IAAA/C,EAHApa,EAAA,KACAoa,uBAEA9W,EAAA2S,EAAAoE,GAIA+C,EAAA,IAAAjG,EAFAnX,EAAA,KACAmX,uBACA7T,EAAA2O,GAIAC,EAAA,IAAA8D,EAFAhW,EAAA,KAAAgW,aAGA1S,EACA2S,EACAhE,GAGA3O,EAAA8T,kBAAAgG,EAAAhG,kBACA9T,EAAAqQ,kBAAA0G,EAAA1G,kBACArQ,EAAA+Z,yBAAA,SAAAhb,GACA,IAAAe,EAAAiX,EAAAoC,kBAAApa,EAAA,MACA,OACAI,cAAAW,EAAAX,eAAA,KACAC,YAAAU,EAAAV,aAAA,KACAF,YAAAY,EAAAZ,aAAA,KACAG,UAAAS,EAAAT,WAAA,OAIAW,EAAAsP,eAAAV,EAAAU,eACAtP,EAAAkT,WAAAtE,EAAAsE,WAEAlT,EAAAK,OAAAyQ,iBAAA7I,EACAjI,EAAAK,OAAAiM,iBAAA,EACAtM,EAAAK,OAAAqP,kCAAA,EACA1P,EAAAK,OAAA+Q,yBAAA,EACApR,EAAAK,OAAA8Q,wBAAA,EACAnR,EAAAK,OAAAiL,+BAAA,EACAtL,EAAAK,OAAA4U,cAAA,KACAjV,EAAAK,OAAAmW,YAAA,KACAxW,EAAAK,OAAAuQ,mBAAA,EA2DA5Q,EAAA+R,cAAA,SAAA3R,EAAAe,GACA,QAAAnB,EAAAuP,UAAA,wBAAAnP,IAAA,CAGAJ,EAAAkP,6BAAA,EAEA,IAAAkI,EAAAL,EAAA4C,eACAvZ,EACAJ,EAAA2C,aAAAvC,GAAAe,EAAA,MAGA6Y,KAEA3P,EAAAsI,EAAAvI,UAAAjJ,GACA,GAAAkJ,EAAA/I,OACAtB,EAAAuP,UAAA,8BAAAlF,QACE,EAzEF,SAAA4P,EAAA9Y,GAEA,GAAAnB,EAAAK,OAAAoQ,8BAMA,QAAA7T,EAAA,EAAgBA,EAAAuE,EAAAG,OAAsB1E,IAAA,CACtC,IAAAiG,EAAA1B,EAAAvE,GACAmC,EAAAiB,EAAA4C,QAAAC,EAAAI,QAEAjD,EAAAK,OAAA8Q,wBAAAtO,EAAAI,QAAAgX,IACApX,EAAAwL,eAAA,IAAA2C,KAAAjS,EAAAC,cA6DAkb,CAAA9Z,EAAAe,GAEA,IAAArB,EAAA+Z,EAAA1C,aAAAhW,EAAAiW,IA1DA,SAAA4C,GAmBA,IAAAG,GAAA,EAQA,SAAAC,IACA,QAAAxd,EAAA,EAAiBA,EAAAod,EAAA1Y,OAAyB1E,IAC1CoD,EAAAqa,WAAAL,EAAApd,IARA,GAAAod,EAAA1Y,OACAtB,EAAA0N,WArBA,SAAA4M,EAAAvb,GACA,IAAAob,EAAA,CAGA,IAAAI,EAAAxb,EAAAC,WAAAgR,UACAwK,EAAAzb,EAAAE,SAAA+Q,UAGA,GADAhQ,EAAAya,kBAAA1b,GACAA,EAAAC,WAAAgR,WAAAuK,GAAAxb,EAAAE,SAAA+Q,WAAAwK,EAKA,IADA,IAAArX,EAAAnD,EAAAoD,YAAArE,EAAAqB,IACAxD,EAAA,GAAiBud,GAAAvd,EAAAuG,EAAA7B,OAAqC1E,IACtD0d,EAAAta,EAAA4C,QAAAO,EAAAvG,UALAud,GAAA,IAYAH,EAAA,IACEA,EAAA1Y,SACF6Y,GAAA,GAQAA,EACAna,EAAAma,YAAAC,GAEAA,KA0BAM,CAFAV,EAAAH,EAAA7B,iBAAAlY,IAKAE,EAAAkP,6BAAA,EACAlP,EAAAuP,UAAA,uBAAAnP,EAAA4Z,MAGAha,EAAAoP,aAAA,SAAAhP,EAAAua,GAOA,IAAAxZ,EALAwZ,OADA5a,IAAA4a,KAGAA,OAIA5a,IAAAK,EACAJ,EAAAK,OAAAua,2BACAjM,EAAA9N,eAAAT,EAAAua,GAEAxZ,EAAA2Y,EAAApJ,2BAAAtQ,GAGAe,EAAAwN,EAAA9N,iBAGAb,EAAA+R,cAAA3R,EAAAe,IAGAnB,EAAA+H,YAAA,yBAAAhJ,GAKA,OAJAA,EAAAuR,iBAAA,iBAAAvR,EAAAuR,kBACAvR,EAAAuR,gBAAAtQ,EAAAoV,KAAAyF,UAAA9b,EAAAuR,gBAAA,eAEAvR,EAAA8R,gBAAA7Q,EAAAqQ,kBAAAtR,IACA,IAEAiB,EAAA+H,YAAA,yBAAAhJ,GAEA,OADAA,EAAA8R,gBAAA7Q,EAAAqQ,kBAAAtR,IACA,KAIA2P,EADAhS,EAAA,KAAAgS,kBACA1O,EAAA2O,EAAAC,EAAAkL","file":"ext/dhtmlxgantt_auto_scheduling.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"ext/dhtmlxgantt_auto_scheduling\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ext/dhtmlxgantt_auto_scheduling\"] = factory();\n\telse\n\t\troot[\"ext/dhtmlxgantt_auto_scheduling\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/codebase/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 271);\n","export class TaskPlan implements ITaskPlan {\n\tstatic Create(parent?: TaskPlan): TaskPlan {\n\t\tconst plan = new TaskPlan();\n\t\tif (parent) {\n\t\t\tfor (const i in plan) {\n\t\t\t\tif (parent[i] !== undefined) {\n\t\t\t\t\tplan[i] = parent[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn plan;\n\t}\n\n\tpublic link: string | number;\n\tpublic task: string | number;\n\t// tslint:disable-next-line variable-name\n\tpublic start_date: Date | null;\n\t// tslint:disable-next-line variable-name\n\tpublic end_date: Date | null;\n\n\tpublic latestStart: Date;\n\tpublic earliestStart: Date;\n\tpublic earliestEnd: Date;\n\tpublic latestEnd: Date;\n\n\tpublic latestSchedulingStart: Date;\n\tpublic earliestSchedulingStart: Date;\n\tpublic latestSchedulingEnd: Date;\n\tpublic earliestSchedulingEnd: Date;\n\n\tpublic kind: string;\n\tpublic conflict: boolean;\n\n\tconstructor() {\n\t\tthis.link = null;\n\t\tthis.task = null;\n\t\tthis.start_date = null;\n\t\tthis.end_date = null;\n\t\tthis.latestStart = null;\n\t\tthis.earliestStart = null;\n\t\tthis.earliestEnd = null;\n\t\tthis.latestEnd = null;\n\t\tthis.latestSchedulingStart = null;\n\t\tthis.earliestSchedulingStart = null;\n\t\tthis.latestSchedulingEnd = null;\n\t\tthis.earliestSchedulingEnd = null;\n\t\tthis.kind = \"asap\";\n\t\tthis.conflict = false;\n\t}\n}","module.exports = function(gantt) {\n\treturn {\n\t\tgetVirtualRoot: function(){\n\t\t\treturn gantt.mixin(\n\t\t\t\tgantt.getSubtaskDates(),\n\t\t\t\t{\n\t\t\t\t\tid: gantt.config.root_id,\n\t\t\t\t\ttype: gantt.config.types.project,\n\t\t\t\t\t$source: [],\n\t\t\t\t\t$target: [],\n\t\t\t\t\t$virtual: true\n\t\t\t\t}\n\t\t\t);\n\t\t},\n\t\n\t\tgetLinkedTasks: function(id, includePredecessors){\n\t\t\tvar startIds = [id];\n\t\n\t\t\t//TODO: format links cache\n\t\t\tvar clearCache = false;\n\t\t\tif(!gantt._isLinksCacheEnabled()) {\n\t\t\t\tgantt._startLinksCache();\n\t\t\t\tclearCache = true;\n\t\t\t}\n\t\t\tvar relations = [];\n\t\t\tvar visited = {};\n\t\t\tvar result = {};\n\t\t\tfor(var i = 0; i < startIds.length; i++){\n\t\t\t\tthis._getLinkedTasks(startIds[i], visited, includePredecessors, result);\n\t\t\t}\n\t\n\t\t\tfor(var i in result){\n\t\t\t\trelations.push(result[i]);\n\t\t\t}\n\t\n\t\t\t//TODO: remove redundant edges before continue https://en.wikipedia.org/wiki/Transitive_reduction\n\t\t\tif(clearCache)\n\t\t\t\tgantt._endLinksCache();\n\t\t\treturn relations;\n\t\t},\n\t\n\t\t_collectRelations: function(rootObj, isChild, includePredecessors, visitedLinks){\n\t\t\tvar successors = gantt._getSuccessors(rootObj, isChild);\n\t\n\t\t\tvar predecessors = [];\n\t\t\tif (includePredecessors) {\n\t\t\t\tpredecessors = gantt._getPredecessors(rootObj, isChild);\n\t\t\t}\n\t\t\t\n\t\t\tvar linkKey;\n\t\t\tvar relations = [];\n\t\t\tfor(var i = 0; i < successors.length; i++){\n\t\t\t\tlinkKey = successors[i].hashSum;\n\t\t\t\tif(visitedLinks[linkKey]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tvisitedLinks[linkKey] = true;\n\t\t\t\t\trelations.push(successors[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(var i = 0; i < predecessors.length; i++){\n\t\t\t\tlinkKey = predecessors[i].hashSum;\n\t\t\t\tif(visitedLinks[linkKey]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tvisitedLinks[linkKey] = true;\n\t\t\t\t\trelations.push(predecessors[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn relations;\n\t\t},\n\t\t_getLinkedTasks: function(rootTask, visitedTasks, includePredecessors, output) {\n\t\t\tvar from = rootTask === undefined ? gantt.config.root_id : rootTask;\n\t\t\tvar visitedTasks = {};\n\t\t\tvar visitedLinks = {};\n\t\t\tvar rootObj;\n\t\n\t\t\tvar tasksStack = [{from: from, includePredecessors: includePredecessors, isChild:false}];\n\t\n\t\t\twhile(tasksStack.length){\n\t\t\t\tvar current = tasksStack.pop();\n\t\t\t\tvar isChild = current.isChild;\n\t\n\t\t\t\tfrom = current.from;\n\t\t\t\tif(visitedTasks[from]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trootObj = gantt.isTaskExists(from) ? gantt.getTask(from) : this.getVirtualRoot();\n\t\t\t\tvisitedTasks[from] = true;\n\t\t\t\t\n\t\t\t\tvar relations = this._collectRelations(rootObj, isChild, includePredecessors, visitedLinks);\n\t\n\t\t\t\tfor(var i=0; i < relations.length; i++){\n\t\t\t\t\tvar rel = relations[i];\n\t\t\t\t\toutput[rel.hashSum] = rel;\n\t\t\t\t\tvar isSameParent = rel.sourceParent == rel.targetParent;\n\t\t\t\t\tvar targetTask = rel.target;\n\t\t\t\t\tif(!visitedTasks[targetTask])\n\t\t\t\t\t\ttasksStack.push({from: rel.target, includePredecessors: true, isChild: isSameParent});\n\t\t\t\t}\n\t\n\t\t\t\tif(gantt.hasChild(rootObj.id)){\n\t\t\t\t\tvar children = gantt.getChildren(rootObj.id);\n\t\t\t\t\tfor(var i=0; i < children.length; i++){\n\t\t\t\t\t\tif(!visitedTasks[children[i]])\n\t\t\t\t\t\t\ttasksStack.push({from: children[i], includePredecessors: true, isChild: true});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn output;\n\t\t}\n\t};\n};","var units = {\n\t\"second\": 1,\n\t\"minute\": 60,\n\t\"hour\": 60 * 60,\n\t\"day\": 60 * 60 * 24,\n\t\"week\": 60 * 60 * 24 * 7,\n\t\"month\": 60 * 60 * 24 * 30,\n\t\"quarter\": 60 * 60 * 24 * 30 * 3,\n\t\"year\": 60 * 60 * 24 * 365\n};\nfunction getSecondsInUnit(unit){\n\treturn units[unit] || units.hour;\n}\n\nfunction forEach(arr, callback) {\n\tif (arr.forEach) {\n\t\tarr.forEach(callback);\n\t} else {\n\t\tvar workArray = arr.slice();\n\t\tfor (var i = 0; i < workArray.length; i++) {\n\t\t\tcallback(workArray[i], i);\n\t\t}\n\t}\n}\n\nfunction arrayMap(arr, callback) {\n\tif (arr.map) {\n\t\treturn arr.map(callback);\n\t} else {\n\t\tvar workArray = arr.slice();\n\t\tvar resArray = [];\n\n\t\tfor (var i = 0; i < workArray.length; i++) {\n\t\t\tresArray.push(callback(workArray[i], i));\n\t\t}\n\t\treturn resArray;\n\t}\n}\n\n\nfunction arrayFind(arr, callback) {\n\tif (arr.find) {\n\t\treturn arr.find(callback);\n\t} else {\n\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\tif (callback(arr[i], i)) {\n\t\t\t\treturn arr[i];\n\t\t\t}\n\t\t}\n\t}\n}\n\n// iframe-safe array type check instead of using instanceof\nfunction isArray(obj){\n\tif(Array.isArray){\n\t\treturn Array.isArray(obj);\n\t}else{\n\t\t// close enough\n\t\treturn (obj && obj.length !== undefined && obj.pop && obj.push);\n\t}\n}\n\n// non-primitive string object, e.g. new String(\"abc\")\nfunction isStringObject(obj){\n\treturn obj && typeof obj === \"object\"\n\t\t&& Function.prototype.toString.call(obj.constructor) === \"function String() { [native code] }\";\n}\n\n// non-primitive number object, e.g. new Number(5)\nfunction isNumberObject(obj){\n\treturn obj && typeof obj === \"object\"\n\t\t&& Function.prototype.toString.call(obj.constructor) === \"function Number() { [native code] }\";\n}\n\n// non-primitive number object, e.g. new Boolean(true)\nfunction isBooleanObject(obj){\n\treturn obj && typeof obj === \"object\"\n\t\t&& Function.prototype.toString.call(obj.constructor) === \"function Boolean() { [native code] }\";\n}\n\nfunction isDate(obj) {\n\tif (obj && typeof obj === \"object\") {\n\t\treturn !!(obj.getFullYear && obj.getMonth && obj.getDate);\n\t} else {\n\t\treturn false;\n\t}\n}\n\nfunction isValidDate(obj){\n\treturn isDate(obj) && !isNaN(obj.getTime());\n}\n\nfunction arrayFilter(arr, callback) {\n\tvar result = [];\n\n\tif (arr.filter) {\n\t\treturn arr.filter(callback);\n\t} else {\n\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\tif (callback(arr[i], i)) {\n\t\t\t\tresult[result.length] = arr[i];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n\nfunction hashToArray(hash) {\n\tvar result = [];\n\n\tfor (var key in hash) {\n\t\tif (hash.hasOwnProperty(key)) {\n\t\t\tresult.push(hash[key]);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nfunction arraySome(arr, callback) {\n\tif (arr.length === 0) return false;\n\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tif (callback(arr[i], i, arr)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction arrayDifference(arr, callback) {\n\treturn arrayFilter(arr, function(item, i) {\n\t\treturn !callback(item, i);\n\t});\n}\n\nfunction throttle (callback, timeout) {\n\tvar wait = false;\n\n\treturn function () {\n\t\tif (!wait) {\n\t\t\tcallback.apply(null, arguments);\n\t\t\twait = true;\n\t\t\tsetTimeout(function () {\n\t\t\t\twait = false;\n\t\t\t}, timeout);\n\t\t}\n\t};\n}\n\nfunction delay (callback, timeout){\n\tvar timer;\n\n\tvar result = function() {\n\t\tresult.$cancelTimeout();\n\t\tcallback.$pending = true;\n\t\tvar args = Array.prototype.slice.call(arguments);\n\t\ttimer = setTimeout(function(){\n\t\t\tcallback.apply(this, args);\n\t\t\tresult.$pending = false;\n\t\t}, timeout);\n\t};\n\t\n\tresult.$pending = false;\n\tresult.$cancelTimeout = function(){\n\t\tclearTimeout(timer);\n\t\tcallback.$pending = false;\n\t};\n\tresult.$execute = function(){\n\t\tcallback();\n\t\tcallback.$cancelTimeout();\n\t};\n\n\treturn result;\n}\n\nfunction sortArrayOfHash(arr, field, desc) {\n\tvar compare = function(a, b) {\n\t\treturn a < b;\n\t};\n\n\tarr.sort(function(a, b) {\n\t\tif (a[field] === b[field]) return 0;\n\n\t\treturn desc ? compare(a[field], b[field]) : compare(b[field], a[field]);\n\t});\n}\n\nfunction objectKeys(obj) {\n\tif (Object.keys) {\n\t\treturn Object.keys(obj);\n\t}\n\tvar result = [];\n\tvar key;\n\tfor (key in obj) {\n\t\tif (Object.prototype.hasOwnProperty.call(obj, key)) {\n\t\t\tresult.push(key);\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction requestAnimationFrame(callback) {\n\tvar w = window;\n\tvar foundRequestAnimationFrame = w.requestAnimationFrame\n\t\t|| w.webkitRequestAnimationFrame\n\t\t|| w.msRequestAnimationFrame\n\t\t|| w.mozRequestAnimationFrame\n\t\t|| w.oRequestAnimationFrame\n\t\t|| function(cb) { setTimeout(cb, 1000/60); };\n\treturn foundRequestAnimationFrame(callback);\n}\n\nfunction isEventable(obj) {\n\treturn obj.attachEvent && obj.detachEvent;\n}\n\nmodule.exports = {\n\tgetSecondsInUnit: getSecondsInUnit,\n\tforEach: forEach,\n\tarrayMap: arrayMap,\n\tarrayFind: arrayFind,\n\tarrayFilter: arrayFilter,\n\tarrayDifference: arrayDifference,\n\tarraySome: arraySome,\n\thashToArray: hashToArray,\n\tsortArrayOfHash: sortArrayOfHash,\n\tthrottle: throttle,\n\tisArray: isArray,\n\tisDate: isDate,\n\tisValidDate: isValidDate,\n\tisStringObject: isStringObject,\n\tisNumberObject: isNumberObject,\n\tisBooleanObject: isBooleanObject,\n\tdelay: delay,\n\tobjectKeys: objectKeys,\n\trequestAnimationFrame: requestAnimationFrame,\n\tisEventable: isEventable\n};","export enum ConstraintTypes {\n\t// As Soon As Possible (ASAP)\n\tASAP = \"asap\",\n\t// As Late As Possible (ALAP)\n\tALAP = \"alap\",\n\t// Start No Earlier Than (SNET)\n\tSNET = \"snet\",\n\t// Start No Later Than (SNLT)\n\tSNLT = \"snlt\",\n\t// Finish No Earlier Than (FNET)\n\tFNET = \"fnet\",\n\t// Finish No Later Than (FNLT)\n\tFNLT = \"fnlt\",\n\t// Must Start On (MSO)\n\tMSO = \"mso\",\n\t// Must Finish On (MFO)\n\tMFO = \"mfo\"\n}","var helpers = require(\"../../utils/helpers\");\n\nmodule.exports = function(){\n\treturn {\n\t\tgetVertices: function(relations){\n\t\t\tvar ids = {};\n\t\t\tvar rel;\n\t\t\tfor(var i = 0, len = relations.length; i < len; i++){\n\t\t\t\trel = relations[i];\n\t\t\t\tids[rel.target] = rel.target;\n\t\t\t\tids[rel.source] = rel.source;\n\t\t\t}\n\n\t\t\tvar vertices = [];\n\t\t\tvar id;\n\t\t\tfor(var i in ids){\n\t\t\t\tid = ids[i];\n\t\t\t\tvertices.push(id);\n\t\t\t}\n\n\t\t\treturn vertices;\n\t\t},\n\t\ttopologicalSort: function(edges){\n\t\t\tvar vertices = this.getVertices(edges);\n\t\t\tvar hash = {};\n\n\t\t\tfor(var i = 0, len = vertices.length; i < len; i ++){\n\t\t\t\thash[vertices[i]] = {id: vertices[i], $source:[], $target:[], $incoming: 0};\n\t\t\t}\n\n\t\t\tfor(var i = 0, len = edges.length; i < len; i++){\n\t\t\t\tvar successor = hash[edges[i].target];\n\t\t\t\tsuccessor.$target.push(i);\n\t\t\t\tsuccessor.$incoming = successor.$target.length;\n\t\t\t\thash[edges[i].source].$source.push(i);\n\n\t\t\t}\n\n\t\t\t// topological sort, Kahn's algorithm\n\t\t\tvar S = vertices.filter(function(v){ return !hash[v].$incoming; });\n\n\t\t\tvar L = [];\n\n\t\t\twhile(S.length){\n\t\t\t\tvar n = S.pop();\n\n\t\t\t\tL.push(n);\n\n\t\t\t\tvar node = hash[n];\n\n\t\t\t\tfor(var i = 0; i < node.$source.length; i++){\n\t\t\t\t\tvar m = hash[edges[node.$source[i]].target];\n\t\t\t\t\tm.$incoming--;\n\t\t\t\t\tif(!m.$incoming){\n\t\t\t\t\t\tS.push(m.id);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn L;\n\n\t\t},\n\t\tgroupAdjacentEdges: function(edges){\n\t\t\tvar res = {};\n\t\t\tvar edge;\n\t\t\tfor(var i = 0, len = edges.length; i < len; i++){\n\t\t\t\tedge = edges[i];\n\t\t\t\tif(!res[edge.source]){\n\t\t\t\t\tres[edge.source] = [];\n\t\t\t\t}\n\t\t\t\tres[edge.source].push(edge);\n\t\t\t}\n\t\t\treturn res;\n\t\t},\n\t\ttarjanStronglyConnectedComponents: function(vertices, edges){\n\t\t\t//https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n\t\t\t// iterative implementation\n\t\t\tvar verticesHash = {};\n\t\t\tvar stack = [];\n\t\t\tvar edgesFromTasks = this.groupAdjacentEdges(edges);\n\t\t\tvar recurse = false;\n\t\t\tvar connectedComponents = [];\n\n\t\t\tfor(var i = 0; i < vertices.length; i++){\n\t\t\t\tvar root = getVertex(vertices[i]);\n\t\t\t\tif(root.visited) continue;\n\t\t\t\tvar workStack = [root];\n\t\t\t\tvar index = 0;\n\t\t\t\twhile(workStack.length){\n\t\t\t\t\tvar v = workStack.pop();\n\n\t\t\t\t\tif(!v.visited){\n\t\t\t\t\t\tv.index = index;\n\t\t\t\t\t\tv.lowLink = index;\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tstack.push(v);\n\t\t\t\t\t\tv.onStack = true;\n\t\t\t\t\t\tv.visited = true;\n\t\t\t\t\t}\n\t\t\t\t\trecurse = false;\n\t\t\t\t\tvar edges = edgesFromTasks[v.id] || [];\n\t\t\t\t\tfor(var e = 0; e < edges.length; e++){\n\t\t\t\t\t\tvar w = getVertex(edges[e].target);\n\t\t\t\t\t\tw.edge = edges[e];\n\t\t\t\t\t\tif(w.index === undefined){\n\t\t\t\t\t\t\tworkStack.push(v);\n\t\t\t\t\t\t\tworkStack.push(w);\n\t\t\t\t\t\t\trecurse = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if(w.onStack){\n\t\t\t\t\t\t\tv.lowLink = Math.min(v.lowLink, w.index);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(recurse)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (v.index == v.lowLink){\n\t\t\t\t\t\tvar com = {tasks:[], links:[]};\n\t\t\t\t\t\twhile(true){\n\t\t\t\t\t\t\tw = stack.pop();\n\t\t\t\t\t\t\tw.onStack = false;\n\t\t\t\t\t\t\tcom.tasks.push(w.id);\n\t\t\t\t\t\t\tif(w.edge){\n\t\t\t\t\t\t\t\tcom.links.push(w.edge.id);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(w == v){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconnectedComponents.push(com);\n\t\t\t\t\t}\n\t\t\t\t\tif(workStack.length){\n\t\t\t\t\t\tw = v;\n\t\t\t\t\t\tv = workStack[workStack.length - 1];\n\t\t\t\t\t\tv.lowLink = Math.min(v.lowLink, w.lowLink);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn connectedComponents;\n\n\t\t\tfunction getVertex(id){\n\t\t\t\tif(!verticesHash[id]){\n\t\t\t\t\tverticesHash[id] = {id: id, onStack:false, index: undefined, lowLink: undefined, edge: undefined};\n\t\t\t\t}\n\n\t\t\t\treturn verticesHash[id];\n\t\t\t}\n\t\t},\n\n\t\tfindLoops: function(relations){\n\t\t\tvar cycles = [];\n\n\t\t\thelpers.forEach(relations, function(rel){\n\t\t\t\tif(rel.target == rel.source)\n\t\t\t\t\tcycles.push([rel.target, rel.source]);\n\t\t\t});\n\n\t\t\tvar vertices = this.getVertices(relations);\n\n\t\t\tvar connectedComponents = this.tarjanStronglyConnectedComponents(vertices, relations);\n\t\t\thelpers.forEach(connectedComponents, function(component){\n\t\t\t\tif(component.tasks.length > 1){\n\t\t\t\t\tcycles.push(component);//{ tasks: [task ids], links: [links ids]}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn cycles;\n\t\t\t//{task:id, link:link.type, lag: link.lag || 0, source: link.source}\n\t\t}\n\t};\n};","module.exports = function (gantt) {\n\t// helpers for building chain of dependencies, used for critical path calculation and for auto scheduling\n\n\tgantt._get_linked_task = function (link, getTarget) {\n\t\tvar task = null;\n\t\tvar taskId = getTarget ? link.target : link.source;\n\n\t\tif (gantt.isTaskExists(taskId)) {\n\t\t\ttask = gantt.getTask(taskId);\n\t\t}\n\n\t\treturn task;\n\t};\n\tgantt._get_link_target = function (link) {\n\t\treturn gantt._get_linked_task(link, true);\n\t};\n\n\tgantt._get_link_source = function (link) {\n\t\treturn gantt._get_linked_task(link, false);\n\t};\n\n\tvar caching = false;\n\tvar formattedLinksStash = {};\n\tvar inheritedSuccessorsStash = {};\n\tvar inheritedPredecessorsStash = {};\n\tvar getPredecessorsCache = {};\n\n\n\tgantt._isLinksCacheEnabled = function () {\n\t\treturn caching;\n\t};\n\tgantt._startLinksCache = function () {\n\t\tformattedLinksStash = {};\n\t\tinheritedSuccessorsStash = {};\n\t\tinheritedPredecessorsStash = {};\n\t\tgetPredecessorsCache = {};\n\t\tcaching = true;\n\t};\n\tgantt._endLinksCache = function () {\n\t\tformattedLinksStash = {};\n\t\tinheritedSuccessorsStash = {};\n\t\tinheritedPredecessorsStash = {};\n\t\tgetPredecessorsCache = {};\n\t\tcaching = false;\n\t};\n\n\tgantt._formatLink = function (link) {\n\n\n\t\tif (caching && formattedLinksStash[link.id]) {\n\t\t\treturn formattedLinksStash[link.id];\n\t\t}\n\n\t\tvar relations = [];\n\t\tvar target = this._get_link_target(link);\n\t\tvar source = this._get_link_source(link);\n\n\t\tif (!(source && target)) {\n\t\t\treturn relations;\n\t\t}\n\n\t\tif ((gantt.isSummaryTask(target) && gantt.isChildOf(source.id, target.id)) || (gantt.isSummaryTask(source) && gantt.isChildOf(target.id, source.id))) {\n\t\t\treturn relations;\n\t\t}\n\n\n\t\t// there are three kinds of connections at this point\n\t\t// task -> task - regular link\n\t\t// task -> project - transform it into set of regular links (task -> [each subtask]), use offset beetween subtask and project dates as lag, in order not to change mutual positions of subtasks inside a project\n\t\t// project -> task - transform it into ([each subtask] -> task) links\n\t\t// project -> project - transform it into ([each subtask of p1] -> [each subtask of p2]) links\n\n\t\tvar from = this._getImplicitLinks(link, source, function (c) {\n\t\t\treturn 0;\n\t\t}, true);\n\n\t\tvar respectTargetOffset = gantt.config.auto_scheduling_move_projects;\n\t\tvar targetDates = this.isSummaryTask(target) ? this.getSubtaskDates(target.id) : {\n\t\t\tstart_date: target.start_date,\n\t\t\tend_date: target.end_date\n\t\t};\n\t\tvar to = this._getImplicitLinks(link, target, function (c) {\n\t\t\tif (!respectTargetOffset) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\n\t\t\t\tif (!c.$target.length && !(gantt.getState().drag_id == c.id)) {// drag_id - virtual lag shouldn't restrict task that is being moved inside project\n\t\t\t\t\treturn gantt.calculateDuration({\n\t\t\t\t\t\tstart_date: targetDates.start_date,\n\t\t\t\t\t\tend_date: c.start_date,\n\t\t\t\t\t\ttask: source\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tfor (var i = 0, fromLength = from.length; i < fromLength; i++) {\n\t\t\tvar fromTask = from[i];\n\t\t\tfor (var j = 0, toLength = to.length; j < toLength; j++) {\n\t\t\t\tvar toTask = to[j];\n\n\t\t\t\tvar lag = fromTask.lag * 1 + toTask.lag * 1;\n\n\t\t\t\tvar subtaskLink = {\n\t\t\t\t\tid: link.id,\n\t\t\t\t\ttype: link.type,\n\t\t\t\t\tsource: fromTask.task,\n\t\t\t\t\ttarget: toTask.task,\n\t\t\t\t\tlag: (link.lag * 1 || 0) + lag\n\t\t\t\t};\n\n\t\t\t\trelations.push(gantt._convertToFinishToStartLink(toTask.task, subtaskLink, source, target, fromTask.taskParent, toTask.taskParent));\n\t\t\t}\n\t\t}\n\n\t\tif (caching)\n\t\t\tformattedLinksStash[link.id] = relations;\n\n\t\treturn relations;\n\t};\n\n\tgantt._isAutoSchedulable = function (task) {\n\t\treturn task.auto_scheduling !== false;\n\t};\n\n\tgantt._getImplicitLinks = function (link, parent, selectOffset, selectSourceLinks) {\n\t\tvar relations = [];\n\n\t\tif (this.isSummaryTask(parent)) {\n\n\t\t\t// if the summary task contains multiple chains of linked tasks - no need to consider every task of the chain,\n\t\t\t// it will be enough to check the first/last tasks of the chain\n\t\t\t// special conditions if there are unscheduled tasks in the chain, or negative lag values that put the end date of the successor task prior to its predecessors' date\n\t\t\tvar children = {};\n\t\t\tthis.eachTask(function (c) {\n\t\t\t\tif (!this.isSummaryTask(c)) {\n\t\t\t\t\tchildren[c.id] = c;\n\t\t\t\t}\n\t\t\t}, parent.id);\n\n\t\t\tvar skipChild;\n\n\t\t\tfor (var c in children) {\n\t\t\t\tvar task = children[c];\n\t\t\t\tvar linksCollection = selectSourceLinks ? task.$source : task.$target;\n\n\t\t\t\tskipChild = false;\n\n\t\t\t\tfor (var l = 0; l < linksCollection.length; l++) {\n\t\t\t\t\tvar siblingLink = gantt.getLink(linksCollection[l]);\n\t\t\t\t\tvar siblingId = selectSourceLinks ? siblingLink.target : siblingLink.source;\n\t\t\t\t\tvar siblingTask = children[siblingId];\n\t\t\t\t\tif (siblingTask && task.auto_scheduling !== false && siblingTask.auto_scheduling !== false) {\n\t\t\t\t\t\tif ((siblingLink.target == siblingTask.id && Math.abs(siblingLink.lag) <= siblingTask.duration) ||\n\t\t\t\t\t\t\t(siblingLink.target == task.id && Math.abs(siblingLink.lag) <= task.duration)) {\n\t\t\t\t\t\t\tskipChild = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!skipChild) {\n\t\t\t\t\trelations.push({ task: task.id, taskParent: task.parent, lag: selectOffset(task) });\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\trelations.push({ task: parent.id, taskParent: parent.parent, lag: 0 });\n\t\t}\n\n\t\treturn relations;\n\t};\n\n\tgantt._getDirectDependencies = function (task, selectSuccessors) {\n\n\t\tvar links = [],\n\t\t\tsuccessors = [];\n\n\t\tvar linksIds = selectSuccessors ? task.$source : task.$target;\n\n\t\tfor (var i = 0; i < linksIds.length; i++) {\n\t\t\tvar link = this.getLink(linksIds[i]);\n\t\t\tif (this.isTaskExists(link.source) && this.isTaskExists(link.target)) {\n\t\t\t\tvar target = this.getTask(link.target);\n\t\t\t\tif (this._isAutoSchedulable(target)) {\n\t\t\t\t\tlinks.push(this.getLink(linksIds[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0; i < links.length; i++) {\n\t\t\tsuccessors = successors.concat(this._formatLink(links[i]));\n\t\t}\n\n\t\treturn successors;\n\t};\n\n\tgantt._getInheritedDependencies = function (task, selectSuccessors) {\n\n\t\t//var successors = [];\n\t\tvar stop = false;\n\t\tvar inheritedRelations = [];\n\t\tvar cacheCollection;\n\t\tif (this.isTaskExists(task.id)) {\n\t\t\tthis.eachParent(function (parent) {\n\t\t\t\tif (stop)\n\t\t\t\t\treturn;\n\n\t\t\t\tif (caching) {\n\t\t\t\t\tcacheCollection = selectSuccessors ? inheritedSuccessorsStash : inheritedPredecessorsStash;\n\t\t\t\t\tif (cacheCollection[parent.id]) {\n\t\t\t\t\t\tinheritedRelations = inheritedRelations.concat(cacheCollection[parent.id]);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar parentDependencies;\n\t\t\t\tif (this.isSummaryTask(parent)) {\n\t\t\t\t\tif (!this._isAutoSchedulable(parent)) {\n\t\t\t\t\t\tstop = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparentDependencies = this._getDirectDependencies(parent, selectSuccessors);\n\t\t\t\t\t\tif (caching) {\n\t\t\t\t\t\t\tcacheCollection[parent.id] = parentDependencies;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tinheritedRelations = inheritedRelations.concat(parentDependencies);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}, task.id, this);\n\t\t}\n\n\t\treturn inheritedRelations;\n\t};\n\n\n\tgantt._getDirectSuccessors = function (task) {\n\t\treturn this._getDirectDependencies(task, true);\n\t};\n\n\tgantt._getInheritedSuccessors = function (task) {\n\t\treturn this._getInheritedDependencies(task, true);\n\t};\n\n\tgantt._getDirectPredecessors = function (task) {\n\t\treturn this._getDirectDependencies(task, false);\n\t};\n\n\tgantt._getInheritedPredecessors = function (task) {\n\t\treturn this._getInheritedDependencies(task, false);\n\t};\n\n\tgantt._getSuccessors = function (task, skipInherited) {\n\t\tvar successors = this._getDirectSuccessors(task);\n\t\tif (skipInherited) {\n\t\t\treturn successors;\n\t\t} else {\n\t\t\treturn successors.concat(this._getInheritedSuccessors(task));\n\t\t}\n\t};\n\n\tgantt._getPredecessors = function (task, skipInherited) {\n\t\tvar key = String(task.id) + \"-\" + String(skipInherited);\n\t\tvar result;\n\n\t\tif (caching && getPredecessorsCache[key]) {\n\t\t\treturn getPredecessorsCache[key];\n\t\t}\n\n\t\tvar predecessors = this._getDirectPredecessors(task);\n\t\tif (skipInherited) {\n\t\t\tresult = predecessors;\n\t\t} else {\n\t\t\tresult = predecessors.concat(this._getInheritedPredecessors(task));\n\t\t}\n\t\tif (caching) {\n\t\t\tgetPredecessorsCache[key] = result;\n\t\t}\n\t\treturn result;\n\t};\n\n\n\tgantt._convertToFinishToStartLink = function (id, link, sourceTask, targetTask, sourceParent, targetParent) {\n\t\t// convert finish-to-finish, start-to-finish and start-to-start to finish-to-start link and provide some additional properties\n\t\tvar res = {\n\t\t\ttarget: id,\n\t\t\tlink: gantt.config.links.finish_to_start,\n\t\t\tid: link.id,\n\t\t\tlag: link.lag || 0,\n\t\t\tsource: link.source,\n\t\t\tpreferredStart: null,\n\t\t\tsourceParent: sourceParent,\n\t\t\ttargetParent: targetParent,\n\t\t\thashSum: null\n\t\t};\n\n\t\tvar additionalLag = 0;\n\t\tswitch (link.type) {\n\t\t\tcase gantt.config.links.start_to_start:\n\t\t\t\tadditionalLag = -sourceTask.duration;\n\t\t\t\tbreak;\n\t\t\tcase gantt.config.links.finish_to_finish:\n\t\t\t\tadditionalLag = -targetTask.duration;\n\t\t\t\tbreak;\n\t\t\tcase gantt.config.links.start_to_finish:\n\t\t\t\tadditionalLag = -sourceTask.duration - targetTask.duration;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tadditionalLag = 0;\n\t\t}\n\n\t\tres.lag += additionalLag;\n\t\tres.hashSum = res.lag + \"_\" + res.link + \"_\" + res.source + \"_\" + res.target;\n\t\treturn res;\n\t};\n};","import { ConnectedGroupsHelper } from \"./connected_groups\";\n\nexport function attachUIHandlers(\n\tgantt: any,\n\tlinksBuilder: any,\n\tloopsFinder: any,\n\tconnectedGroupsHelper: ConnectedGroupsHelper\n) {\n\tlet _attachAutoSchedulingHandlers = function() {\n\t\tlet _scheduleAfterBatchUpdate = false;\n\t\tgantt.attachEvent(\"onAfterBatchUpdate\", function(){\n\n\t\t\tif(_scheduleAfterBatchUpdate){\n\t\t\t\tgantt.autoSchedule();\n\t\t\t}\n\t\t\t_scheduleAfterBatchUpdate = false;\n\t\t});\n\n\t\tfunction _autoScheduleAfterLinkChange(id: LinkID, link: ILink) {\n\t\t\tif (gantt.config.auto_scheduling && !gantt._autoscheduling_in_progress) {\n\t\t\t\tif(gantt.getState().batch_update){\n\t\t\t\t\t_scheduleAfterBatchUpdate = true;\n\t\t\t\t}else{\n\t\t\t\t\tgantt.autoSchedule(link.source);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgantt.attachEvent(\"onAfterLinkUpdate\", _autoScheduleAfterLinkChange);\n\t\tgantt.attachEvent(\"onAfterLinkAdd\", _autoScheduleAfterLinkChange);\n\n\t\tgantt.attachEvent(\"onAfterLinkDelete\", function(id: LinkID, link: ILink) {\n\t\t\tif (\n\t\t\t\tgantt.config.auto_scheduling &&\n\t\t\t\t!gantt._autoscheduling_in_progress &&\n\t\t\t\tgantt.isTaskExists(link.target)\n\t\t\t) {\n\t\t\t\t// after link deleted - auto schedule target for other relations that may be left\n\t\t\t\tconst target = gantt.getTask(link.target);\n\t\t\t\tconst predecessors = gantt._getPredecessors(target);\n\t\t\t\tif (predecessors.length) {\n\t\t\t\t\tif(gantt.getState().batch_update){\n\t\t\t\t\t\t_scheduleAfterBatchUpdate = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tgantt.autoSchedule(predecessors[0].source, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tgantt.attachEvent(\"onParse\", function() {\n\t\t\tif (\n\t\t\t\tgantt.config.auto_scheduling &&\n\t\t\t\tgantt.config.auto_scheduling_initial\n\t\t\t) {\n\t\t\t\tgantt.autoSchedule();\n\t\t\t}\n\t\t});\n\n\t\tfunction _preventCircularLink(id: LinkID, link: ILink): boolean {\n\t\t\tif (gantt.isCircularLink(link)) {\n\t\t\t\tgantt.callEvent(\"onCircularLinkError\", [\n\t\t\t\t\tlink,\n\t\t\t\t\tloopsFinder.getLoopContainingLink(link)\n\t\t\t\t]);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tfunction _preventDescendantLink(id: LinkID, link: ILink): boolean {\n\t\t\tconst source = gantt.getTask(link.source);\n\t\t\tconst target = gantt.getTask(link.target);\n\n\t\t\tif (!gantt.config.auto_scheduling_descendant_links) {\n\t\t\t\tif (\n\t\t\t\t\t(gantt.isChildOf(source.id, target.id) &&\n\t\t\t\t\t\tgantt.isSummaryTask(target)) ||\n\t\t\t\t\t(gantt.isChildOf(target.id, source.id) && gantt.isSummaryTask(source))\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tgantt.attachEvent(\"onBeforeLinkAdd\", _preventCircularLink);\n\t\tgantt.attachEvent(\"onBeforeLinkAdd\", _preventDescendantLink);\n\t\tgantt.attachEvent(\"onBeforeLinkUpdate\", _preventCircularLink);\n\t\tgantt.attachEvent(\"onBeforeLinkUpdate\", _preventDescendantLink);\n\n\t\tfunction _datesNotEqual(\n\t\t\tdateA: Date,\n\t\t\tdateB: Date,\n\t\t\ttaskA: ITask,\n\t\t\ttaskB: ITask\n\t\t): boolean {\n\t\t\tif (!!dateA !== !!dateB) {\n\t\t\t\t// if one of dates is empty or null and the other is not\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (!dateA && !dateB) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (dateA.valueOf() > dateB.valueOf()) {\n\t\t\t\treturn gantt._hasDuration({\n\t\t\t\t\tstart_date: dateB,\n\t\t\t\t\tend_date: dateA,\n\t\t\t\t\ttask: taskB\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn gantt._hasDuration({\n\t\t\t\t\tstart_date: dateA,\n\t\t\t\t\tend_date: dateB,\n\t\t\t\t\ttask: taskA\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tfunction _notEqualTaskDates(task1: ITask, task2: ITask): boolean {\n\t\t\tif (_datesNotEqual(task1.start_date, task2.start_date, task1, task2)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (gantt.getConstraintType(task1) !== gantt.getConstraintType(task2)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t_datesNotEqual(\n\t\t\t\t\ttask1.constraint_date,\n\t\t\t\t\ttask2.constraint_date,\n\t\t\t\t\ttask1,\n\t\t\t\t\ttask2\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t_datesNotEqual(task1.start_date, task2.start_date, task1, task2) ||\n\t\t\t\t((_datesNotEqual(task1.end_date, task2.end_date, task1, task2) ||\n\t\t\t\t\ttask1.duration !== task2.duration) &&\n\t\t\t\t\ttask1.type !== gantt.config.types.milestone)\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tfunction getRelations(id: TaskID) {\n\t\t\t// collect relations before drag and drop  in order to have original positions of subtasks within project since they are used as lag when moving dependent project\n\n\t\t\t// TODO: remove in 7.0\n\t\t\tif (gantt.config.auto_scheduling_compatibility) {\n\t\t\t\t// collect only downstream dependencies since there is no backward or ALAP scheduling in pre 6.1 auto scheduling\n\t\t\t\treturn linksBuilder.getLinkedTasks(id, true);\n\t\t\t} else {\n\t\t\t\t// get all connected group (both upstream and downstream dependencies)\n\t\t\t\treturn connectedGroupsHelper.getConnectedGroupRelations(id);\n\t\t\t}\n\t\t}\n\n\t\tlet relations;\n\t\tlet movedTask;\n\t\tgantt.attachEvent(\"onBeforeTaskDrag\", function(\n\t\t\tid: TaskID,\n\t\t\tmode: string,\n\t\t\ttask: ITask\n\t\t) {\n\t\t\tif (\n\t\t\t\tgantt.config.auto_scheduling &&\n\t\t\t\tgantt.config.auto_scheduling_move_projects\n\t\t\t) {\n\t\t\t\t// collect relations before drag and drop  in order to have original positions of subtasks within project since they are used as lag when moving dependent project\n\t\t\t\trelations = getRelations(id);\n\n\t\t\t\tmovedTask = id;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\n\t\tfunction resetToStartLinksLags(taskId, relationsArray) {\n\t\t\t// task duration is used as lag when converting start_to_start and start_to_finish into finish_to_start links\n\t\t\t// recalculate these links if task duration has changed\n\n\t\t\tlet skipped = false;\n\t\t\tfor (let i = 0; i < relations.length; i++) {\n\t\t\t\tconst originalLink = gantt.getLink(relationsArray[i].id);\n\t\t\t\tif (\n\t\t\t\t\toriginalLink &&\n\t\t\t\t\t(originalLink.type === gantt.config.links.start_to_start ||\n\t\t\t\t\t\toriginalLink.type === gantt.config.links.start_to_finish)\n\t\t\t\t) {\n\t\t\t\t\trelationsArray.splice(i, 1);\n\t\t\t\t\ti--;\n\t\t\t\t\tskipped = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (skipped) {\n\t\t\t\tconst presentLinks = {};\n\t\t\t\tfor (let i = 0; i < relationsArray.length; i++) {\n\t\t\t\t\tpresentLinks[relationsArray[i].id] = true;\n\t\t\t\t}\n\n\t\t\t\tconst updatedLinks = getRelations(taskId);\n\n\t\t\t\tfor (let i = 0; i < updatedLinks.length; i++) {\n\t\t\t\t\tif (!presentLinks[updatedLinks[i].id]) {\n\t\t\t\t\t\trelationsArray.push(updatedLinks[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction updateTaskConstraints(task){\n\t\t\tif (gantt.config.schedule_from_end) {\n\t\t\t\ttask.constraint_type = gantt.config.constraint_types.FNLT;\n\t\t\t\ttask.constraint_date = new Date(task.end_date);\n\t\t\t} else {\n\t\t\t\ttask.constraint_type = gantt.config.constraint_types.SNET;\n\t\t\t\ttask.constraint_date = new Date(task.start_date);\n\t\t\t}\n\t\t}\n\n\t\tfunction finalizeTaskConstraints(task){\n\t\t\t// TODO: remove in 7.0\n\t\t\tif (gantt.config.auto_scheduling_compatibility && gantt.config.auto_scheduling_strict) {\n\t\t\t\tif (task.constraint_type === gantt.config.constraint_types.SNET ||\n\t\t\t\t\ttask.constraint_type === gantt.config.constraint_types.FNLT) {\n\t\t\t\t\t\ttask.constraint_type = null;\n\t\t\t\t\t\ttask.constraint_date = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst _autoScheduleAfterDND = function(taskId, task) {\n\t\t\tif (gantt.config.auto_scheduling && !gantt._autoscheduling_in_progress) {\n\t\t\t\tconst newTask = gantt.getTask(taskId);\n\n\t\t\t\tif (_notEqualTaskDates(task, newTask)) {\n\t\t\t\t\tupdateTaskConstraints(newTask);\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tgantt.config.auto_scheduling_move_projects &&\n\t\t\t\t\t\t// tslint:disable-next-line triple-equals\n\t\t\t\t\t\tmovedTask == taskId\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tgantt.calculateDuration(task) !== gantt.calculateDuration(newTask)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// task duration is used as lag when converting start_to_start and start_to_finish into finish to start links\n\t\t\t\t\t\t\t// recalculate these links if task duration has changed\n\t\t\t\t\t\t\tresetToStartLinksLags(taskId, relations);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgantt._autoSchedule(taskId, relations);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgantt.autoSchedule(newTask.id);\n\t\t\t\t\t}\n\n\t\t\t\t\tfinalizeTaskConstraints(newTask);\n\t\t\t\t}\n\t\t\t}\n\t\t\trelations = null;\n\t\t\tmovedTask = null;\n\t\t\treturn true;\n\t\t};\n\n\n\n\n\t\tlet modifiedTaskId = null;\n\t\tif (gantt.ext && gantt.ext.inlineEditors) {\n\t\t\tconst inlineEditors = gantt.ext.inlineEditors;\n\t\t\tconst autoscheduleColumns = {\n\t\t\t\tstart_date: true,\n\t\t\t\tend_date: true,\n\t\t\t\tduration: true,\n\t\t\t\tconstraint_type: true,\n\t\t\t\tconstraint_date: true\n\t\t\t};\n\n\t\t\tinlineEditors.attachEvent(\"onBeforeSave\", function(state) {\n\t\t\t\tif (autoscheduleColumns[state.columnName]) {\n\t\t\t\t\tmodifiedTaskId = state.id;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\n\t\tlet changedConstraint;\n\t\tfunction onBeforeLigthboxSaveHandler(taskId: TaskID, task: ITask): boolean {\n\t\t\tif (gantt.config.auto_scheduling && !gantt._autoscheduling_in_progress) {\n\t\t\t\tchangedConstraint = false;\n\t\t\t\tconst oldTask = gantt.getTask(taskId);\n\t\t\t\tif (_notEqualTaskDates(task, oldTask)) {\n\t\t\t\t\tmodifiedTaskId = taskId;\n\t\t\t\t\tif(gantt.getConstraintType(task) !== gantt.getConstraintType(oldTask) ||\n\t\t\t\t\t\t+task.constraint_date !== +oldTask.constraint_date\n\t\t\t\t\t){\n\t\t\t\t\t\tchangedConstraint = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tfunction onAfterTaskUpdateHandler(taskId: TaskID, task: ITask): boolean {\n\t\t\tif (gantt.config.auto_scheduling && !gantt._autoscheduling_in_progress) {\n\t\t\t\tif (\n\t\t\t\t\tmodifiedTaskId &&\n\t\t\t\t\t// tslint:disable-next-line triple-equals\n\t\t\t\t\tmodifiedTaskId == taskId\n\t\t\t\t) {\n\t\t\t\t\tmodifiedTaskId = null;\n\t\t\t\t\tif(!changedConstraint){\n\t\t\t\t\t\tupdateTaskConstraints(task);\n\t\t\t\t\t}\n\t\t\t\t\tgantt.autoSchedule(task.id);\n\n\t\t\t\t\tif(!changedConstraint){\n\t\t\t\t\t\tfinalizeTaskConstraints(task);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tgantt.attachEvent(\"onBeforeTaskChanged\", function(\n\t\t\tid: TaskID,\n\t\t\tmode: string,\n\t\t\ttask: ITask\n\t\t) {\n\t\t\treturn _autoScheduleAfterDND(id, task);\n\t\t});\n\n\t\tif(gantt.ext.inlineEditors){\n\t\t\tgantt.ext.inlineEditors.attachEvent(\"onBeforeSave\", function(state){\n\t\t\t\tif (gantt.config.auto_scheduling && !gantt._autoscheduling_in_progress) {\n\t\t\t\t\tconst api = gantt.ext.inlineEditors;\n\t\t\t\t\tconst editorConfig = api.getEditorConfig(state.columnName);\n\t\t\t\t\tif(editorConfig.map_to === \"start_date\" || editorConfig.map_to === \"end_date\" || editorConfig.map_to === \"duration\"){\n\t\t\t\t\t\tmodifiedTaskId = state.id;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\n\t\tgantt.attachEvent(\"onLightboxSave\", onBeforeLigthboxSaveHandler);\n\t\tgantt.attachEvent(\"onAfterTaskUpdate\", onAfterTaskUpdateHandler);\n\t};\n\n\tgantt.attachEvent(\"onGanttReady\", function() {\n\t\t_attachAutoSchedulingHandlers();\n\t\t// attach handlers only when initialized for the first time\n\t\t_attachAutoSchedulingHandlers = function() { };\n\t});\n}\n","export class LoopsFinder {\n\tprivate _linksBuilder: any;\n\tprivate _graphHelper: any;\n\tprivate _gantt: any;\n\tconstructor(gantt: any, graphHelper: any, linksBuilder: any) {\n\t\tthis._linksBuilder = linksBuilder;\n\t\tthis._graphHelper = graphHelper;\n\t\tthis._gantt = gantt;\n\t}\n\tisCircularLink = (link: ILink): boolean => {\n\t\treturn !!this.getLoopContainingLink(link);\n\t}\n\n\tgetLoopContainingLink = (link: ILink): any => {\n\t\tconst graphHelper = this._graphHelper;\n\t\tconst linksBuilder = this._linksBuilder;\n\t\tconst gantt = this._gantt;\n\n\t\tlet allRelations = linksBuilder.getLinkedTasks();\n\t\tif (!gantt.isLinkExists(link.id)) {\n\t\t\tallRelations = allRelations.concat(gantt._formatLink(link));\n\t\t}\n\n\t\tconst cycles = graphHelper.findLoops(allRelations);\n\n\t\tconst found = false;\n\t\tfor (let i = 0; i < cycles.length && !found; i++) {\n\t\t\tconst links = cycles[i].links;\n\t\t\tfor (let j = 0; j < links.length; j++) {\n\t\t\t\t// tslint:disable-next-line triple-equals\n\t\t\t\tif (links[j] == link.id) {\n\t\t\t\t\treturn cycles[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tfindCycles = () => {\n\t\tconst graphHelper = this._graphHelper;\n\t\tconst linksBuilder = this._linksBuilder;\n\n\t\tconst allRelations = linksBuilder.getLinkedTasks();\n\t\treturn graphHelper.findLoops(allRelations);\n\t}\n}\n","interface IFlagHash {\n\t[id: string]: boolean;\n}\n\nfunction findGroups(links: IInternalLink[]): IConnectedGroup[] {\n\tconst visited: IFlagHash = {};\n\tconst groups = [];\n\tlet source: TaskID;\n\tlet target: TaskID;\n\tlet root: TaskID;\n\t// main loop - find any unvisited vertex from the input array and\n\t// treat it as the source, then perform a breadth first search from\n\t// it. All vertices visited from this search belong to the same group\n\tfor (let i = 0; i < links.length; i++) {\n\t\tsource = links[i].source;\n\t\ttarget = links[i].target;\n\t\troot = null;\n\t\tif (!visited[source]) {\n\t\t\troot = source;\n\t\t} else if (!visited[target]) {\n\t\t\troot = target;\n\t\t}\n\t\tif (root) {\n\t\t\t// there is an unvisited vertex in this pair.\n\t\t\t// perform a breadth first search, and push the resulting\n\t\t\t// group onto the list of all groups\n\t\t\tconst length = links.length;\n\t\t\tgroups.push(breadthFirstSearch(root, links, visited));\n\t\t\tif (length !== links.length) {\n\t\t\t\ti = -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn groups;\n}\n\n// Breadth First Search function\n// v is the source vertex\n// links is the input array, which contains all gantt relations\n// visited is a dictionary for keeping track of whether a node is visited\nfunction breadthFirstSearch(\n\tv: TaskID,\n\tlinks: IInternalLink[],\n\tvisited: IFlagHash\n): IConnectedGroupsDetailed {\n\tconst queue: TaskID[] = [v];\n\tconst groupTasks: TaskID[] = [];\n\tconst groupLinksInternal: { [hashSum: string]: IInternalLink } = {};\n\tconst groupLinksPublic: { [id: string]: boolean } = {};\n\n\tlet currentVertex: TaskID;\n\twhile (queue.length > 0) {\n\t\tcurrentVertex = queue.shift();\n\t\tif (!visited[currentVertex]) {\n\t\t\tvisited[currentVertex] = true;\n\t\t\tgroupTasks.push(currentVertex);\n\t\t\t// go through the input array to find vertices that are\n\t\t\t// directly adjacent to the current vertex, and put them\n\t\t\t// onto the queue\n\t\t\tfor (let i = 0; i < links.length; i++) {\n\t\t\t\tconst link = links[i];\n\t\t\t\t// tslint:disable-next-line triple-equals\n\t\t\t\tif ((link.source == currentVertex || link.sourceParent == currentVertex)) {\n\t\t\t\t\tif (!visited[link.target]) {\n\t\t\t\t\t\tqueue.push(link.target);\n\t\t\t\t\t\tgroupLinksPublic[link.id] = true;\n\t\t\t\t\t\tlinks.splice(i, 1);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t\tgroupLinksInternal[link.hashSum] = link;\n\n\t\t\t\t\t// tslint:disable-next-line triple-equals\n\t\t\t\t} else if ((link.target == currentVertex || link.targetParent == currentVertex)) {\n\t\t\t\t\tif (!visited[link.source]) {\n\t\t\t\t\t\tqueue.push(link.source);\n\t\t\t\t\t\tgroupLinksPublic[link.id] = true;\n\t\t\t\t\t\tlinks.splice(i, 1);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t\tgroupLinksInternal[link.hashSum] = link;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tconst linksArray: LinkID[] = [];\n\tconst linksObjects: IInternalLink[] = [];\n\tfor (const i in groupLinksPublic) {\n\t\tlinksArray.push(i);\n\t}\n\tfor (const i in groupLinksInternal) {\n\t\tlinksObjects.push(groupLinksInternal[i]);\n\t}\n\t// return everything in the current \"group\"\n\treturn { tasks: groupTasks, links: linksArray, processedLinks: linksObjects };\n}\n\nexport class ConnectedGroupsHelper {\n\tprivate _linksBuilder: any;\n\tprivate _gantt: any;\n\tconstructor(gantt: any, linksBuilder: any) {\n\t\tthis._linksBuilder = linksBuilder;\n\t\tthis._gantt = gantt;\n\t}\n\n\tgetConnectedGroupRelations = (id: TaskID): IInternalLink[] => {\n\t\tconst links = this._linksBuilder.getLinkedTasks();\n\t\tconst group = breadthFirstSearch(id, links, {});\n\t\treturn group.processedLinks;\n\t}\n\n\tgetConnectedGroup = (id: TaskID): IConnectedGroup | IConnectedGroup[] => {\n\t\tconst links = this._linksBuilder.getLinkedTasks();\n\t\tif (id !== undefined) {\n\t\t\tif (this._gantt.getTask(id).type === this._gantt.config.types.project) {\n\t\t\t\treturn { tasks: [], links: [] };\n\t\t\t}\n\n\t\t\tconst group = breadthFirstSearch(id, links, {});\n\t\t\treturn {\n\t\t\t\ttasks: group.tasks,\n\t\t\t\tlinks: group.links\n\t\t\t};\n\t\t} else {\n\t\t\treturn findGroups(links).map(group => ({ tasks: group.tasks, links: group.links }));\n\t\t}\n\t}\n}\n","import { TaskPlan } from \"./task_plan\";\n\nexport class AsapStrategy implements ISchedulingStrategy {\n\tstatic Create(gantt: any): AsapStrategy {\n\t\tconst instance = new AsapStrategy();\n\t\tinstance._gantt = gantt;\n\t\treturn instance;\n\t}\n\n\tprotected _gantt: any;\n\n\tresolveRelationDate(\n\t\ttaskId: TaskID,\n\t\tadjacentLinks: ITaskRelations,\n\t\tplansHash: IPlansHash\n\t): TaskPlan {\n\t\tlet minStart = null;\n\t\tlet linkId = null;\n\n\t\tlet defaultStart = null;\n\t\tconst task = this._gantt.getTask(taskId);\n\t\tconst relations = adjacentLinks.predecessors;\n\n\t\tlet minRelationDate = null;\n\t\tfor (let i = 0; i < relations.length; i++) {\n\t\t\tconst relation = relations[i];\n\n\t\t\t// .preferredStart still exists only to emulate pre 6.1 auto scheduling behavior\n\t\t\t// will be removed in future versions\n\t\t\t// TODO: remove .preferredStart in v7.0\n\t\t\tdefaultStart = relation.preferredStart;\n\n\t\t\tconst constraintDate = this.getEarliestStartDate(\n\t\t\t\trelation,\n\t\t\t\tplansHash,\n\t\t\t\ttask\n\t\t\t);\n\n\t\t\tif (this.isSmallerOrDefault(minRelationDate, constraintDate, task)) {\n\t\t\t\tminRelationDate = constraintDate;\n\t\t\t}\n\t\t\tif (\n\t\t\t\tthis.isSmallerOrDefault(defaultStart, constraintDate, task) &&\n\t\t\t\tthis.isSmallerOrDefault(minStart, constraintDate, task)\n\t\t\t) {\n\t\t\t\tminStart = constraintDate;\n\t\t\t\tlinkId = relation.id;\n\t\t\t}\n\t\t}\n\n\t\tif (!relations.length && this._gantt.config.project_start) {\n\t\t\tif (this.isSmallerOrDefault(task.start_date, this._gantt.config.project_start, task)) {\n\t\t\t\tminStart = this._gantt.config.project_start;\n\t\t\t}\n\t\t}\n\n\t\tlet maxEnd = null;\n\t\tif (minStart) {\n\t\t\tminStart = this._gantt.getClosestWorkTime({\n\t\t\t\tdate: minStart,\n\t\t\t\tdir: \"future\",\n\t\t\t\ttask\n\t\t\t});\n\t\t\tmaxEnd = this._gantt.calculateEndDate({\n\t\t\t\tstart_date: minStart,\n\t\t\t\tduration: task.duration,\n\t\t\t\ttask\n\t\t\t});\n\t\t}\n\n\t\tconst masterPlan = plansHash[taskId];\n\t\tconst currentPlan = TaskPlan.Create(masterPlan);\n\n\t\tcurrentPlan.link = linkId;\n\t\tcurrentPlan.task = taskId;\n\t\tcurrentPlan.start_date = minStart;\n\t\tcurrentPlan.end_date = maxEnd;\n\t\tcurrentPlan.kind = \"asap\";\n\n\t\tif (minRelationDate) {\n\t\t\tcurrentPlan.earliestSchedulingStart = minRelationDate;\n\t\t\tcurrentPlan.earliestSchedulingEnd = this._gantt.calculateEndDate({\n\t\t\t\tstart_date: minRelationDate,\n\t\t\t\tduration: task.duration,\n\t\t\t\ttask\n\t\t\t});\n\t\t}\n\n\t\treturn currentPlan;\n\t}\n\n\tprotected isEqual(dateA: Date, dateB: Date, task: ITask): boolean {\n\t\treturn !this._gantt._hasDuration(dateA, dateB, task);\n\t}\n\n\tprotected isFirstSmaller(small: Date, big: Date, task: ITask): boolean {\n\t\tif (small.valueOf() < big.valueOf() && !this.isEqual(small, big, task)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprotected isSmallerOrDefault(smallDate: Date, bigDate: Date, task: ITask): boolean {\n\t\treturn !!(!smallDate || this.isFirstSmaller(smallDate, bigDate, task));\n\t}\n\n\tprotected getPredecessorEndDate(id: TaskID, plansHash: IPlansHash): Date {\n\t\tconst plan = plansHash[id];\n\t\tconst task = this._gantt.getTask(id);\n\t\tlet res;\n\n\t\tif (!(plan && (plan.start_date || plan.end_date))) {\n\t\t\tres = task.end_date;\n\t\t} else if (plan.end_date) {\n\t\t\tres = plan.end_date;\n\t\t} else {\n\t\t\tres = this._gantt.calculateEndDate({\n\t\t\t\tstart_date: plan.start_date,\n\t\t\t\tduration: task.duration,\n\t\t\t\ttask\n\t\t\t});\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tprotected getEarliestStartDate(relation: IInternalLink, plansHash: IPlansHash, task: ITask): Date {\n\t\tconst predecessorEnd = this.getPredecessorEndDate(\n\t\t\trelation.source,\n\t\t\tplansHash\n\t\t);\n\t\tconst successor = task;\n\n\t\tlet successorStart = this._gantt.getClosestWorkTime({\n\t\t\tdate: predecessorEnd,\n\t\t\tdir: \"future\",\n\t\t\ttask: successor\n\t\t});\n\n\t\tif (\n\t\t\tpredecessorEnd &&\n\t\t\trelation.lag &&\n\t\t\trelation.lag * 1 === relation.lag * 1\n\t\t) {\n\t\t\tsuccessorStart = this._gantt.calculateEndDate({\n\t\t\t\tstart_date: predecessorEnd,\n\t\t\t\tduration: relation.lag * 1,\n\t\t\t\ttask: successor\n\t\t\t});\n\t\t}\n\n\t\treturn successorStart;\n\t}\n}\n","import { TaskPlan } from \"./task_plan\";\n\nexport class AlapStrategy implements ISchedulingStrategy {\n\tstatic Create(gantt: any): AlapStrategy {\n\t\tconst instance = new AlapStrategy();\n\t\tinstance._gantt = gantt;\n\t\treturn instance;\n\t}\n\n\tprotected _gantt: any;\n\n\n\tresolveRelationDate(taskId: TaskID, adjacentLinks: ITaskRelations, plansHash: IPlansHash): TaskPlan {\n\t\tlet maxEnd = null;\n\t\tlet linkId = null;\n\t\tlet maxStart = null;\n\t\tlet defaultStart = null;\n\t\tconst task = this._gantt.getTask(taskId);\n\t\tconst relations = adjacentLinks.successors;\n\t\tlet maxRelationDate = null;\n\t\tconst masterPlan = plansHash[taskId];\n\t\tfor (let i = 0; i < relations.length; i++) {\n\t\t\tconst relation = relations[i];\n\n\t\t\t// .preferredStart still exists only to emulate pre 6.1 auto scheduling behavior\n\t\t\t// will be removed in future versions\n\t\t\t// TODO: remove .preferredStart in v7.0\n\t\t\tdefaultStart = relation.preferredStart;\n\t\t\tconst constraintDate = this.getLatestEndDate(relation, plansHash, task);\n\t\t\tconst constraintStartDate = this._gantt.calculateEndDate({ start_date: constraintDate, duration: - task.duration, task });\n\n\t\t\tif (this.isGreaterOrDefault(maxRelationDate, constraintDate, task)) {\n\t\t\t\tmaxRelationDate = constraintDate;\n\t\t\t}\n\t\t\tif (this.isGreaterOrDefault(defaultStart, constraintStartDate, task) && this.isGreaterOrDefault(maxEnd, constraintDate, task)) {\n\t\t\t\tmaxEnd = constraintDate;\n\t\t\t\tmaxStart = constraintStartDate;\n\t\t\t\tlinkId = relation.id;\n\t\t\t}\n\t\t}\n\n\t\tif (!relations.length && this._gantt.config.project_end) {\n\t\t\tif (this.isGreaterOrDefault(this._gantt.config.project_end, task.end_date, task)) {\n\t\t\t\tmaxEnd = this._gantt.config.project_end;\n\t\t\t}\n\t\t}\n\n\t\tif (maxEnd) {\n\n\t\t\tmaxEnd = this._gantt.getClosestWorkTime({ date: maxEnd, dir: \"future\", task });\n\t\t\tmaxStart = this._gantt.calculateEndDate({ start_date: maxEnd, duration: - task.duration, task });\n\t\t}\n\n\t\tconst currentPlan = TaskPlan.Create(masterPlan);\n\n\t\tcurrentPlan.link = linkId;\n\t\tcurrentPlan.task = taskId;\n\t\tcurrentPlan.end_date = maxEnd;\n\t\tcurrentPlan.start_date = maxStart;\n\t\tcurrentPlan.kind = \"alap\";\n\n\t\tif (maxRelationDate) {\n\t\t\tcurrentPlan.latestSchedulingStart = this._gantt.calculateEndDate({ start_date: maxRelationDate, duration: - task.duration, task });\n\t\t\tcurrentPlan.latestSchedulingEnd = maxRelationDate;\n\t\t}\n\n\t\treturn currentPlan;\n\n\t}\n\n\tprotected isFirstSmaller(small: Date, big: Date, task: ITask): boolean {\n\t\tif (small.valueOf() < big.valueOf() && this._gantt._hasDuration(small, big, task)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprotected isGreaterOrDefault(smallDate: Date, bigDate: Date, task: ITask): boolean {\n\t\treturn !!(!smallDate || this.isFirstSmaller(bigDate, smallDate, task));\n\t}\n\n\tprotected getSuccessorStartDate(id: TaskID, plansHash: IPlansHash): Date {\n\t\tconst plan = plansHash[id];\n\t\tconst task = this._gantt.getTask(id);\n\t\tlet res;\n\n\t\tif (!(plan && (plan.start_date || plan.end_date))) {\n\t\t\tres = task.start_date;\n\t\t} else if (plan.start_date) {\n\t\t\tres = plan.start_date;\n\t\t} else {\n\t\t\tres = this._gantt.calculateEndDate({ start_date: plan.end_date, duration: - task.duration, task });\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tprotected getLatestEndDate(relation: IInternalLink, plansHash: IPlansHash, task: ITask) {\n\t\tconst successorStart = this.getSuccessorStartDate(relation.target, plansHash);\n\t\tconst predecessor = task;\n\n\t\tlet predecessorEnd = this._gantt.getClosestWorkTime({ date: successorStart, dir: \"past\", task: predecessor });\n\n\t\tif (predecessorEnd && relation.lag && relation.lag * 1 === relation.lag * 1) {\n\t\t\tpredecessorEnd = this._gantt.calculateEndDate({ start_date: predecessorEnd, duration: -relation.lag * 1, task: predecessor });\n\t\t}\n\n\t\treturn predecessorEnd;\n\t}\n}","import { AlapStrategy } from \"./alap_strategy\";\nimport { AsapStrategy } from \"./asap_strategy\";\nimport { ConstraintTypes } from \"./constraint_types\";\nimport { ConstraintsHelper } from \"./constraints\";\nimport { TaskPlan } from \"./task_plan\";\n\nexport class AutoSchedulingPlanner {\n\tprivate _gantt: any;\n\tprivate _constraintsHelper: ConstraintsHelper;\n\tprivate _graphHelper: any;\n\tprivate _asapStrategy: AsapStrategy;\n\tprivate _alapStrategy: AlapStrategy;\n\n\tconstructor(\n\t\tgantt: any,\n\t\tgraphHelper: any,\n\t\tconstraintsHelper: ConstraintsHelper\n\t) {\n\t\tthis._gantt = gantt;\n\t\tthis._constraintsHelper = constraintsHelper;\n\t\tthis._graphHelper = graphHelper;\n\t\tthis._asapStrategy = AsapStrategy.Create(gantt);\n\t\tthis._alapStrategy = AlapStrategy.Create(gantt);\n\t}\n\n\tgeneratePlan(relations: IInternalLink[], constraints: ITask[]): TaskPlan[] {\n\t\tconst graphHelper = this._graphHelper;\n\t\tconst gantt = this._gantt;\n\t\tconst constraintsHelper = this._constraintsHelper;\n\t\tconst alapStrategy = this._alapStrategy;\n\t\tconst asapStrategy = this._asapStrategy;\n\n\t\tconst {\n\t\t\torderedIds,\n\t\t\treversedIds,\n\t\t\trelationsMap,\n\t\t\tplansHash } = this.buildWorkCollections(relations, constraints, graphHelper);\n\n\t\tlet result: TaskPlan[];\n\n\t\tthis.processConstraints(orderedIds, plansHash, gantt, constraintsHelper);\n\n\t\tif (gantt.config.schedule_from_end) {\n\t\t\t// when scheduling from end - iterate tasks from end and schedule them as late as possible\n\t\t\t// after that - iterate tasks from start and schedule asap tasks\n\t\t\tresult = this.iterateTasks(reversedIds, orderedIds, constraintsHelper.isAlapTask, alapStrategy, asapStrategy, relationsMap, plansHash);\n\t\t} else {\n\t\t\t// when scheduling from end - iterate tasks from start and schedule them as soon as possible\n\t\t\t// after that - iterate tasks from end and schedule asap alap\n\t\t\tresult = this.iterateTasks(orderedIds, reversedIds, constraintsHelper.isAsapTask, asapStrategy, alapStrategy, relationsMap, plansHash);\n\t\t}\n\t\treturn result;\n\t}\n\n\tapplyProjectPlan(projectPlan: TaskPlan[]): ITask[] {\n\t\tconst gantt = this._gantt;\n\n\t\tlet plan: TaskPlan;\n\t\tlet task: ITask;\n\t\tlet link: ILink;\n\t\tlet reason: ITask;\n\n\t\tconst updateTasks = [];\n\t\tfor (let i = 0; i < projectPlan.length; i++) {\n\t\t\tlink = null;\n\t\t\treason = null;\n\t\t\tplan = projectPlan[i];\n\n\t\t\tif (!plan.task) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttask = gantt.getTask(plan.task);\n\t\t\tif (plan.link) {\n\t\t\t\tlink = gantt.getLink(plan.link);\n\t\t\t\tif (plan.kind === \"asap\") {\n\t\t\t\t\treason = this._gantt.getTask(link.source);\n\t\t\t\t} else {\n\t\t\t\t\t// alap tasks are scheduled by their successors\n\t\t\t\t\treason = this._gantt.getTask(link.target);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet newDate = null;\n\t\t\tif (\n\t\t\t\tplan.start_date &&\n\t\t\t\ttask.start_date.valueOf() !== plan.start_date.valueOf()\n\t\t\t) {\n\t\t\t\tnewDate = plan.start_date;\n\t\t\t}\n\n\t\t\tif (!newDate) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttask.start_date = newDate;\n\t\t\ttask.end_date = gantt.calculateEndDate(task);\n\n\t\t\tupdateTasks.push(task.id);\n\t\t\tgantt.callEvent(\"onAfterTaskAutoSchedule\", [\n\t\t\t\ttask,\n\t\t\t\tnewDate,\n\t\t\t\tlink,\n\t\t\t\treason\n\t\t\t]);\n\t\t}\n\t\treturn updateTasks;\n\t}\n\n\tprotected iterateTasks(\n\t\tmainSequence: TaskID[],\n\t\tsecondarySequence: TaskID[],\n\t\tisMainSequence: (task: ITask) => boolean,\n\t\tmainSequenceStrategy: ISchedulingStrategy,\n\t\tsecondarySequenceStrategy: ISchedulingStrategy,\n\t\trelationsMap: ITaskLinksMap,\n\t\tplansHash: IPlansHash\n\n\t): TaskPlan[] {\n\t\tconst gantt = this._gantt;\n\t\tconst result: TaskPlan[] = [];\n\n\t\tfor (let i = 0; i < mainSequence.length; i++) {\n\t\t\tconst currentId = mainSequence[i];\n\t\t\tconst task = gantt.getTask(currentId);\n\t\t\tconst plan = mainSequenceStrategy.resolveRelationDate(\n\t\t\t\tcurrentId,\n\t\t\t\trelationsMap[currentId],\n\t\t\t\tplansHash\n\t\t\t);\n\t\t\tthis.limitPlanDates(task, plan);\n\t\t\tif (isMainSequence(task)) {\n\t\t\t\tthis.processResolvedDate(task, plan, result, plansHash);\n\t\t\t} else {\n\t\t\t\tplansHash[task.id] = plan;\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < secondarySequence.length; i++) {\n\t\t\tconst currentId = secondarySequence[i];\n\t\t\tconst task = gantt.getTask(currentId);\n\n\t\t\tif (!isMainSequence(task)) {\n\t\t\t\tconst plan = secondarySequenceStrategy.resolveRelationDate(\n\t\t\t\t\tcurrentId,\n\t\t\t\t\trelationsMap[currentId],\n\t\t\t\t\tplansHash\n\t\t\t\t);\n\t\t\t\tthis.limitPlanDates(task, plan);\n\t\t\t\tthis.processResolvedDate(task, plan, result, plansHash);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprotected processResolvedDate(\n\t\ttask: ITask,\n\t\tplan: TaskPlan,\n\t\tresult: TaskPlan[],\n\t\tplansHash: any\n\t): void {\n\t\tif (plan.start_date && this._gantt.isLinkExists(plan.link)) {\n\t\t\tlet link = null;\n\t\t\tlet reason = null;\n\t\t\tif (plan.link) {\n\t\t\t\tlink = this._gantt.getLink(plan.link);\n\t\t\t\tif (plan.kind === \"asap\") {\n\t\t\t\t\treason = this._gantt.getTask(link.source);\n\t\t\t\t} else {\n\t\t\t\t\t// alap tasks are scheduled by their successors\n\t\t\t\t\treason = this._gantt.getTask(link.target);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\ttask.start_date.valueOf() !== plan.start_date.valueOf() &&\n\t\t\t\tthis._gantt.callEvent(\"onBeforeTaskAutoSchedule\", [\n\t\t\t\t\ttask,\n\t\t\t\t\tplan.start_date,\n\t\t\t\t\tlink,\n\t\t\t\t\treason\n\t\t\t\t]) === false\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tplansHash[task.id] = plan;\n\t\tif (plan.start_date) {\n\t\t\tresult.push(plan);\n\t\t}\n\t}\n\n\tprotected limitPlanDates(task: ITask, plan: TaskPlan): TaskPlan {\n\t\tconst effectiveStart = plan.start_date || task.start_date;\n\n\t\tif (plan.earliestStart) {\n\t\t\tif (effectiveStart < plan.earliestStart) {\n\t\t\t\tplan.start_date = plan.earliestStart;\n\t\t\t\tplan.end_date = plan.earliestEnd;\n\t\t\t}\n\t\t}\n\n\t\tif (plan.latestStart) {\n\t\t\tif (effectiveStart > plan.latestStart) {\n\t\t\t\tplan.start_date = plan.latestStart;\n\t\t\t\tplan.end_date = plan.latestEnd;\n\t\t\t}\n\t\t}\n\n\t\tif (plan.latestSchedulingStart && effectiveStart > plan.latestSchedulingStart) {\n\t\t\tplan.start_date = plan.latestSchedulingStart;\n\t\t\tplan.end_date = plan.latestSchedulingEnd;\n\t\t}\n\n\t\tif (plan.earliestSchedulingStart && effectiveStart < plan.earliestSchedulingStart) {\n\t\t\tplan.start_date = plan.earliestSchedulingStart;\n\t\t\tplan.end_date = plan.earliestSchedulingEnd;\n\t\t}\n\n\t\tif (plan.start_date) { // start/end dates are either both defined or both not\n\t\t\tif (plan.start_date > plan.latestSchedulingStart ||\n\t\t\t\tplan.start_date < plan.earliestSchedulingStart ||\n\t\t\t\tplan.start_date > plan.latestStart ||\n\t\t\t\tplan.start_date < plan.earliestStart ||\n\t\t\t\tplan.end_date > plan.latestSchedulingEnd ||\n\t\t\t\tplan.end_date < plan.earliestSchedulingEnd ||\n\t\t\t\tplan.end_date > plan.latestEnd ||\n\t\t\t\tplan.end_date < plan.earliestEnd) {\n\n\t\t\t\tplan.conflict = true;\n\t\t\t}\n\t\t}\n\t\treturn plan;\n\t}\n\n\tprotected buildWorkCollections(relations: IInternalLink[], constraints: ITask[], graphHelper: any) {\n\t\tconst gantt = this._gantt;\n\t\tconst orderedIds: TaskID[] = graphHelper.topologicalSort(relations);\n\t\tconst reversedIds: TaskID[] = orderedIds.slice().reverse();\n\t\tconst plansHash: IPlansHash = {};\n\n\t\tconst relationsMap: ITaskLinksMap = {};\n\t\tfor (let i = 0, len = orderedIds.length; i < len; i++) {\n\t\t\tconst id = orderedIds[i];\n\t\t\tconst task = gantt.getTask(id);\n\t\t\tif (task.auto_scheduling === false) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trelationsMap[id] = {\n\t\t\t\tsuccessors: [],\n\t\t\t\tpredecessors: []\n\t\t\t};\n\n\t\t\tplansHash[id] = null;\n\t\t}\n\n\t\tfor (let i = 0, len = constraints.length; i < len; i++) {\n\t\t\tconst task = constraints[i];\n\n\t\t\tif (plansHash[task.id] === undefined) {\n\t\t\t\treversedIds.unshift(task.id);\n\t\t\t\torderedIds.unshift(task.id);\n\t\t\t\tplansHash[task.id] = null;\n\t\t\t\trelationsMap[task.id] = {\n\t\t\t\t\tsuccessors: [],\n\t\t\t\t\tpredecessors: []\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0, len = relations.length; i < len; i++) {\n\t\t\tconst rel = relations[i];\n\t\t\tif (relationsMap[rel.source]) {\n\t\t\t\trelationsMap[rel.source].successors.push(rel);\n\t\t\t}\n\n\t\t\tif (relationsMap[rel.target]) {\n\t\t\t\trelationsMap[rel.target].predecessors.push(rel);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\torderedIds,\n\t\t\treversedIds,\n\t\t\trelationsMap,\n\t\t\tplansHash\n\t\t};\n\t}\n\n\tprotected processConstraints(orderedIds: TaskID[], plansHash: IPlansHash, gantt: any, constraintsHelper: ConstraintsHelper) {\n\t\tfor (let i = 0; i < orderedIds.length; i++) {\n\t\t\tconst currentId = orderedIds[i];\n\t\t\tconst task = gantt.getTask(currentId);\n\n\t\t\tconst constraintType = constraintsHelper.getConstraintType(task);\n\t\t\tif (\n\t\t\t\tconstraintType &&\n\t\t\t\tconstraintType !== ConstraintTypes.ASAP &&\n\t\t\t\tconstraintType !== ConstraintTypes.ALAP\n\t\t\t) {\n\t\t\t\tconst plan = constraintsHelper.processConstraint(\n\t\t\t\t\ttask,\n\t\t\t\t\tTaskPlan.Create()\n\t\t\t\t);\n\t\t\t\tplansHash[task.id] = plan;\n\t\t\t}\n\t\t}\n\t}\n}\n","import * as helpers from \"../../utils/helpers\";\nimport { ConstraintTypes } from \"./constraint_types\";\nimport { TaskPlan } from \"./task_plan\";\n\nexport class ConstraintsHelper {\n\tstatic Create(gantt: any): ConstraintsHelper {\n\t\treturn new ConstraintsHelper(gantt);\n\t}\n\n\tprivate _gantt: any;\n\tprivate constructor(gantt: any) {\n\t\tthis._gantt = gantt;\n\t}\n\n\tisAsapTask = (task: ITask): boolean => {\n\t\tconst constraintType = this.getConstraintType(task);\n\t\tif (this._gantt.config.schedule_from_end) {\n\t\t\tif (constraintType === ConstraintTypes.ASAP) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (constraintType === ConstraintTypes.ALAP) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\tisAlapTask = (task: ITask): boolean => {\n\t\treturn !this.isAsapTask(task);\n\t}\n\n\tgetConstraintType = (task: ITask): ConstraintTypes => {\n\t\t// in case of backward scheduling, tasks without explicit constraints are considered ALAP tasks\n\t\tif (task.constraint_type) {\n\t\t\treturn task.constraint_type;\n\t\t} else if (this._gantt.config.schedule_from_end) {\n\t\t\treturn ConstraintTypes.ALAP;\n\t\t} else {\n\t\t\treturn ConstraintTypes.ASAP;\n\t\t}\n\t}\n\n\thasConstraint = (task: ITask): boolean => {\n\t\treturn !!this.getConstraintType(task);\n\t}\n\n\tprocessConstraint = (task: ITask, plan: TaskPlan): TaskPlan => {\n\t\tif (this.hasConstraint(task)) {\n\t\t\tif (\n\t\t\t\ttask.constraint_type === ConstraintTypes.ALAP ||\n\t\t\t\ttask.constraint_type === ConstraintTypes.ASAP\n\t\t\t) {\n\t\t\t\t// this kind of constraint is calculated after main scheduling\n\t\t\t} else if(helpers.isValidDate(task.constraint_date)) {\n\t\t\t\tconst constraintDate = task.constraint_date;\n\n\t\t\t\tconst newPlan = TaskPlan.Create(plan);\n\t\t\t\tnewPlan.task = task.id;\n\n\t\t\t\tswitch (task.constraint_type) {\n\t\t\t\t\tcase ConstraintTypes.SNET:\n\t\t\t\t\t\tnewPlan.earliestStart = new Date(constraintDate);\n\t\t\t\t\t\tnewPlan.earliestEnd = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: newPlan.earliestStart,\n\t\t\t\t\t\t\tduration: task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ConstraintTypes.SNLT:\n\t\t\t\t\t\tnewPlan.latestStart = new Date(constraintDate);\n\t\t\t\t\t\tnewPlan.latestEnd = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: newPlan.latestStart,\n\t\t\t\t\t\t\tduration: task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ConstraintTypes.FNET:\n\t\t\t\t\t\tnewPlan.earliestStart = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: constraintDate,\n\t\t\t\t\t\t\tduration: -task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.earliestEnd = new Date(constraintDate);\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ConstraintTypes.FNLT:\n\t\t\t\t\t\tnewPlan.latestStart = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: constraintDate,\n\t\t\t\t\t\t\tduration: -task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.latestEnd = new Date(constraintDate);\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ConstraintTypes.MSO:\n\t\t\t\t\t\tnewPlan.earliestStart = new Date(constraintDate);\n\t\t\t\t\t\tnewPlan.earliestEnd = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: newPlan.earliestStart,\n\t\t\t\t\t\t\tduration: task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.latestStart = newPlan.earliestStart;\n\t\t\t\t\t\tnewPlan.latestEnd = newPlan.earliestEnd;\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ConstraintTypes.MFO:\n\t\t\t\t\t\tnewPlan.earliestStart = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: constraintDate,\n\t\t\t\t\t\t\tduration: -task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.earliestEnd = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: newPlan.earliestStart,\n\t\t\t\t\t\t\tduration: task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.latestStart = newPlan.earliestStart;\n\t\t\t\t\t\tnewPlan.latestEnd = newPlan.earliestEnd;\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\treturn newPlan;\n\t\t\t}\n\t\t}\n\n\t\treturn plan;\n\t}\n\n\tgetConstraints = (id: TaskID, relations: IInternalLink[]): ITask[] => {\n\t\tconst result = [];\n\t\tconst tasks = {};\n\n\t\tconst store = (task: any) => {\n\t\t\tif (tasks[task.id]) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (this.hasConstraint(task) && !this._gantt.isSummaryTask(task)) {\n\t\t\t\ttasks[task.id] = task;\n\t\t\t}\n\t\t};\n\n\t\tif (this._gantt.isTaskExists(id)) {\n\t\t\tconst task = this._gantt.getTask(id);\n\t\t\tstore(task);\n\t\t}\n\n\t\tthis._gantt.eachTask(task => store(task), id);\n\n\t\tlet current;\n\t\tif (relations) {\n\t\t\tfor (let i = 0; i < relations.length; i++) {\n\t\t\t\tconst rel = relations[i];\n\t\t\t\tif (!tasks[rel.target]) {\n\t\t\t\t\tcurrent = this._gantt.getTask(rel.target);\n\t\t\t\t\tstore(current);\n\t\t\t\t}\n\t\t\t\tif (!tasks[rel.source]) {\n\t\t\t\t\tcurrent = this._gantt.getTask(rel.source);\n\t\t\t\t\tstore(current);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const taskId in tasks) {\n\t\t\tresult.push(tasks[taskId]);\n\t\t}\n\n\t\treturn result;\n\t}\n}\n","require(\"../core/relations/links_common\")(gantt);\n\nvar linksBuilder = require(\"../core/relations/links_builder\")(gantt);\nvar graphHelper = require(\"../core/relations/graph_helper\")(gantt);\nvar ConstraintTypes = require(\"./auto_scheduling/constraint_types\").ConstraintTypes;\n\nvar constraintsHelper = require(\"./auto_scheduling/constraints\").ConstraintsHelper.Create(\n\tgantt\n);\nvar AutoSchedulingPlanner = require(\"./auto_scheduling/planner\")\n\t.AutoSchedulingPlanner;\n\nvar planner = new AutoSchedulingPlanner(gantt, graphHelper, constraintsHelper);\n\nvar ConnectedGroupsHelper = require(\"./auto_scheduling/connected_groups\")\n\t.ConnectedGroupsHelper;\nvar connectedGroups = new ConnectedGroupsHelper(gantt, linksBuilder);\n\nvar LoopsFinder = require(\"./auto_scheduling/loops_finder\").LoopsFinder;\n\nvar loopsFinder = new LoopsFinder(\n\tgantt,\n\tgraphHelper,\n\tlinksBuilder\n);\n\ngantt.getConnectedGroup = connectedGroups.getConnectedGroup;\ngantt.getConstraintType = constraintsHelper.getConstraintType;\ngantt.getConstraintLimitations = function (task) {\n\tvar plan = constraintsHelper.processConstraint(task, null);\n\treturn {\n\t\tearliestStart: plan.earliestStart || null,\n\t\tearliestEnd: plan.earliestEnd || null,\n\t\tlatestStart: plan.latestStart || null,\n\t\tlatestEnd: plan.latestEnd || null\n\t};\n};\n\ngantt.isCircularLink = loopsFinder.isCircularLink;\ngantt.findCycles = loopsFinder.findCycles;\n\ngantt.config.constraint_types = ConstraintTypes;\ngantt.config.auto_scheduling = false;\ngantt.config.auto_scheduling_descendant_links = false;\ngantt.config.auto_scheduling_initial = true;\ngantt.config.auto_scheduling_strict = false;\ngantt.config.auto_scheduling_move_projects = true;\ngantt.config.project_start = null;\ngantt.config.project_end = null;\ngantt.config.schedule_from_end = false;\n\nfunction preferInitialTaskDates(startTask, relations) {\n\t// TODO: remove in 7.0\n\tif (!gantt.config.auto_scheduling_compatibility) {\n\t\treturn;\n\t}\n\n\t// .preferredStart still exists only to emulate pre 6.1 auto scheduling behavior\n\t// will be removed in future versions\n\tfor (var i = 0; i < relations.length; i++) {\n\t\tvar rel = relations[i];\n\t\tvar task = gantt.getTask(rel.target);\n\n\t\tif (!gantt.config.auto_scheduling_strict || rel.target == startTask) {\n\t\t\trel.preferredStart = new Date(task.start_date);\n\t\t}\n\t}\n}\n\nfunction updateParentsAndCallEvents(updatedTasks) {\n\tfunction resetTime(task) {\n\t\tif (batchUpdate)\n\t\t\treturn;\n\n\t\tvar start = task.start_date.valueOf(),\n\t\t\tend = task.end_date.valueOf();\n\n\t\tgantt.resetProjectDates(task);\n\t\tif (task.start_date.valueOf() != start || task.end_date.valueOf() != end) {\n\t\t\tbatchUpdate = true;\n\t\t\treturn;\n\t\t}\n\t\tvar children = gantt.getChildren(task.id);\n\t\tfor (var i = 0; !batchUpdate && i < children.length; i++) {\n\t\t\tresetTime(gantt.getTask(children[i]));\n\t\t}\n\t}\n\n\tvar batchUpdate = false;\n\t// call batchUpdate (full repaint) only if we update multiple tasks,\n\tif (updatedTasks.length == 1) {\n\t\tgantt.eachParent(resetTime, updatedTasks[0]);\n\t} else if (updatedTasks.length) {\n\t\tbatchUpdate = true;\n\t}\n\n\tfunction payload() {\n\t\tfor (var i = 0; i < updatedTasks.length; i++) {\n\t\t\tgantt.updateTask(updatedTasks[i]);\n\t\t}\n\t}\n\tif (batchUpdate) {\n\t\tgantt.batchUpdate(payload);\n\t} else {\n\t\tpayload();\n\t}\n}\n\ngantt._autoSchedule = function (id, relations) {\n\tif (gantt.callEvent(\"onBeforeAutoSchedule\", [id]) === false) {\n\t\treturn;\n\t}\n\tgantt._autoscheduling_in_progress = true;\n\n\tvar constraints = constraintsHelper.getConstraints(\n\t\tid,\n\t\tgantt.isTaskExists(id) ? relations : null\n\t);\n\n\tvar updatedTasks = [];\n\n\tvar cycles = graphHelper.findLoops(relations);\n\tif (cycles.length) {\n\t\tgantt.callEvent(\"onAutoScheduleCircularLink\", [cycles]);\n\t} else {\n\t\tpreferInitialTaskDates(id, relations);\n\n\t\tvar plan = planner.generatePlan(relations, constraints);\n\t\tupdatedTasks = planner.applyProjectPlan(plan);\n\n\t\tupdateParentsAndCallEvents(updatedTasks);\n\t}\n\n\tgantt._autoscheduling_in_progress = false;\n\tgantt.callEvent(\"onAfterAutoSchedule\", [id, updatedTasks]);\n};\n\ngantt.autoSchedule = function (id, inclusive) {\n\tif (inclusive === undefined) {\n\t\tinclusive = true;\n\t} else {\n\t\tinclusive = !!inclusive;\n\t}\n\n\tvar relations;\n\tif (id !== undefined) {\n\t\tif (gantt.config.auto_scheduling_compatible) {\n\t\t\tlinksBuilder.getLinkedTasks(id, inclusive);\n\t\t} else {\n\t\t\trelations = connectedGroups.getConnectedGroupRelations(id);\n\t\t}\n\t} else {\n\t\trelations = linksBuilder.getLinkedTasks();\n\t}\n\n\tgantt._autoSchedule(id, relations);\n};\n\ngantt.attachEvent(\"onTaskLoading\", function (task) {\n\tif (task.constraint_date && typeof task.constraint_date === \"string\") {\n\t\ttask.constraint_date = gantt.date.parseDate(task.constraint_date, \"parse_date\");\n\t}\n\ttask.constraint_type = gantt.getConstraintType(task);\n\treturn true;\n});\ngantt.attachEvent(\"onTaskCreated\", function (task) {\n\ttask.constraint_type = gantt.getConstraintType(task);\n\treturn true;\n});\n\nvar attachUIHandlers = require(\"./auto_scheduling/ui_handlers\").attachUIHandlers;\nattachUIHandlers(gantt, linksBuilder, loopsFinder, connectedGroups);\n"],"sourceRoot":""}